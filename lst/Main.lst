   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"Main.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text._sbrk_r,"ax",%progbits
  19              		.align	2
  20              		.global	_sbrk_r
  21              		.thumb
  22              		.thumb_func
  24              	_sbrk_r:
  25              	.LFB55:
  26              		.file 1 "./src/Main.c"
   1:./src/Main.c  **** 
   2:./src/Main.c  **** #include "LPC17xx.h"
   3:./src/Main.c  **** #include "lpc_types.h"
   4:./src/Main.c  **** #include "debug_frmwrk.h"
   5:./src/Main.c  **** #include "inter_volatile.h"
   6:./src/Main.c  **** #include "lpc17xx_systick.h"
   7:./src/Main.c  **** #include "lpc17xx_pinsel.h"
   8:./src/Main.c  **** #include "L1754adc.h"
   9:./src/Main.c  **** #include "stdio.h"
  10:./src/Main.c  **** #include "lpc17xx_mcpwm.h"
  11:./src/Main.c  **** #include "Application.h"
  12:./src/Main.c  **** #include "string.h"
  13:./src/Main.c  **** 
  14:./src/Main.c  **** 
  15:./src/Main.c  **** void receivingHandler(void);
  16:./src/Main.c  **** 
  17:./src/Main.c  **** void _sbrk_r(void){
  27              		.loc 1 17 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 7047     		bx	lr
  33              		.cfi_endproc
  34              	.LFE55:
  36 0002 00BF     		.section	.text.addrCheck,"ax",%progbits
  37              		.align	2
  38              		.global	addrCheck
  39              		.thumb
  40              		.thumb_func
  42              	addrCheck:
  43              	.LFB57:
  18:./src/Main.c  **** 
  19:./src/Main.c  **** }
  20:./src/Main.c  **** 
  21:./src/Main.c  **** 
  22:./src/Main.c  **** #define		N 	50 // amount of commands
  23:./src/Main.c  **** #define		L 	25 // length of command
  24:./src/Main.c  **** 
  25:./src/Main.c  **** //#define true	1
  26:./src/Main.c  **** //#define false	0
  27:./src/Main.c  **** 
  28:./src/Main.c  **** #define MB_ADDRESS_SLAVE_1    '0'
  29:./src/Main.c  **** #define MB_ADDRESS_SLAVE_2 	  '1'
  30:./src/Main.c  **** #define MB_ADDRESS_SLAVE    1
  31:./src/Main.c  **** typedef unsigned char UCHAR;
  32:./src/Main.c  **** 
  33:./src/Main.c  **** volatile char ch, Buf[255];
  34:./src/Main.c  **** volatile uint16_t n=0;
  35:./src/Main.c  **** 
  36:./src/Main.c  **** static uint16_t mainPointer = 0;
  37:./src/Main.c  **** 
  38:./src/Main.c  **** 
  39:./src/Main.c  **** typedef struct
  40:./src/Main.c  **** {
  41:./src/Main.c  **** 	char number;
  42:./src/Main.c  **** 	char flag;
  43:./src/Main.c  ****     char name[L];
  44:./src/Main.c  ****     char length;
  45:./src/Main.c  ****     char argFlag;
  46:./src/Main.c  **** }myCom;
  47:./src/Main.c  **** 
  48:./src/Main.c  **** myCom CommList[N] =
  49:./src/Main.c  **** {
  50:./src/Main.c  **** /*  +-------+--------+--------------------+---------+----------------------------------------------
  51:./src/Main.c  ****  *  |number	| flag	 |	str of function	  |  length | flag for arg = 0b0000000
  52:./src/Main.c  ****  * 	+-------+--------+--------------------+---------+------------------+++++++---------------------
  53:./src/Main.c  ****  * 	|		|		 |					  |				               |||||||
  54:./src/Main.c  ****  * 	|		|		 |					  |				               ||||||+------- without argument 		0x01
  55:./src/Main.c  ****  * 	|		|		 |					  |				               |||||+-------- only numbers			0x02
  56:./src/Main.c  ****  * 	|		|		 |					  |				               ||||+--------- alphabetical symbols	0x04
  57:./src/Main.c  ****  * 	|		|		 |					  |				               |||+----------
  58:./src/Main.c  ****  * 	|		|		 |					  |				               ||+-----------
  59:./src/Main.c  ****  * 	|		|		 |					  |				               |+------------
  60:./src/Main.c  ****  * 	|		|		 |					  |				               +-------------
  61:./src/Main.c  ****  */
  62:./src/Main.c  **** 	  {0, 	  0,		"0000",				0,						0	},
  63:./src/Main.c  **** 	  {1,	  0, 		"ADDR",				4,						0x02},
  64:./src/Main.c  ****       {2,	  0, 		"B",				1,						0x02},
  65:./src/Main.c  ****       {3,	  0, 		"BAUD",				4,						0x02},
  66:./src/Main.c  ****       {4,	  0, 		"BO",				2,						0x02},
  67:./src/Main.c  ****       {5,	  0, 		"BS",				2,						0x02},
  68:./src/Main.c  ****       {6,	  0, 		"CONF",				4,						0x02},
  69:./src/Main.c  ****       {7,	  0, 		"D",				1,						0x04},
  70:./src/Main.c  ****       {8, 	  0,		"FLASH",			5,						0x02},
  71:./src/Main.c  ****       {9, 	  0,		"INT",				3,						0x02},
  72:./src/Main.c  ****       {10, 	  0,		"O",				1,						0x02},
  73:./src/Main.c  ****       {11, 	  0,		"PT",				2,						0x02},
  74:./src/Main.c  ****       {12, 	  0,		"RST",				3,						0x01},
  75:./src/Main.c  ****       {13, 	  0,		"RST/C",			5,						0x01},
  76:./src/Main.c  ****       {14, 	  0,		"S",				1,						0x02},
  77:./src/Main.c  ****       {15, 	  0,		"WRITE",			5,						0x01},
  78:./src/Main.c  ****       {16, 	  0,		"RESETTOFACTORY",	14,						0x01}
  79:./src/Main.c  **** 
  80:./src/Main.c  **** 
  81:./src/Main.c  **** };
  82:./src/Main.c  **** 
  83:./src/Main.c  **** 
  84:./src/Main.c  **** myCom *pCom = &CommList[0];								//testing
  85:./src/Main.c  **** 
  86:./src/Main.c  **** enum{false,true};
  87:./src/Main.c  **** volatile union fltype
  88:./src/Main.c  **** {
  89:./src/Main.c  **** 	volatile struct bites
  90:./src/Main.c  **** 	{
  91:./src/Main.c  **** 		 unsigned start:		1;
  92:./src/Main.c  **** 		 unsigned adrDone:		1;
  93:./src/Main.c  **** 		 unsigned comDone:		1;
  94:./src/Main.c  **** 		 unsigned allEnd: 		1;
  95:./src/Main.c  **** 
  96:./src/Main.c  **** 		 unsigned secondS:       1;
  97:./src/Main.c  **** 		 unsigned secondN:       1;
  98:./src/Main.c  **** 		 unsigned Restart:      1;
  99:./src/Main.c  **** 	}bits;
 100:./src/Main.c  **** 	char allFlags;
 101:./src/Main.c  **** }byte;
 102:./src/Main.c  **** 
 103:./src/Main.c  **** volatile struct bites *pbit = &byte.bits;
 104:./src/Main.c  **** 
 105:./src/Main.c  **** typedef enum
 106:./src/Main.c  **** {
 107:./src/Main.c  **** 	doNothing,
 108:./src/Main.c  **** 	clearing,
 109:./src/Main.c  **** 	checkingAddress,
 110:./src/Main.c  **** 	iniSecondsS,
 111:./src/Main.c  **** 	checkingCommand,
 112:./src/Main.c  **** 	checkingArgument,
 113:./src/Main.c  **** 	executing
 114:./src/Main.c  **** }Stat;
 115:./src/Main.c  **** volatile Stat myStat;
 116:./src/Main.c  **** 
 117:./src/Main.c  **** 
 118:./src/Main.c  **** 
 119:./src/Main.c  **** 
 120:./src/Main.c  **** void
 121:./src/Main.c  **** UART0_IRQHandler(void)
 122:./src/Main.c  **** {
 123:./src/Main.c  **** 	unsigned long iir;
 124:./src/Main.c  **** 
 125:./src/Main.c  **** 	iir = LPC_UART0->IIR;
 126:./src/Main.c  **** 
 127:./src/Main.c  **** 	if ((iir & 0x4) || (iir & 0xC)) {            // RDA or CTI pending
 128:./src/Main.c  **** //	    while (LPC_UART0->LSR & 0x01) {                 // Rx FIFO is not empty
 129:./src/Main.c  **** //	      SER_BUF_WR(ser_in, LPC_UART0->RBR);           // Read Rx FIFO to buffer
 130:./src/Main.c  **** //	    }
 131:./src/Main.c  **** 		receivingHandler();
 132:./src/Main.c  **** 		//LPC_GPIO0->FIOSET0 |= (1<<1);
 133:./src/Main.c  **** 	//	_db_msg(LPC_UART0, "\r\nYES");
 134:./src/Main.c  **** 
 135:./src/Main.c  **** 	  }
 136:./src/Main.c  **** 	  if ((iir & 0x2)) {                           // TXMIS pending
 137:./src/Main.c  **** 
 138:./src/Main.c  **** 	  }
 139:./src/Main.c  **** }
 140:./src/Main.c  **** 
 141:./src/Main.c  **** //inline
 142:./src/Main.c  **** 
 143:./src/Main.c  **** //void addrCheck(volatile char* pBuf, uint16_t *nSymFunc)
 144:./src/Main.c  **** //{
 145:./src/Main.c  **** //	/* Необходим спецификатор static, так как ждем прихода
 146:./src/Main.c  **** //	 * алфавитного символа, чтобы проверить последние символы в буфере. */
 147:./src/Main.c  **** //	static UCHAR address = 0;
 148:./src/Main.c  **** //	char str[15];
 149:./src/Main.c  **** //	 /* Allow only numbers. */
 150:./src/Main.c  **** //	if (*(pBuf) >= '0' && *(pBuf) <= '9')
 151:./src/Main.c  **** //	{
 152:./src/Main.c  **** //		 /* Converting address, taking only last 2 symbols from pBuf. */
 153:./src/Main.c  **** //		address = 10*(*(pBuf - 1) - '0') + (*(pBuf) - '0');
 154:./src/Main.c  **** //	}
 155:./src/Main.c  **** //	else
 156:./src/Main.c  **** //	{
 157:./src/Main.c  **** //		 /* Checking address. */
 158:./src/Main.c  **** //		if (address == MB_ADDRESS_SLAVE)
 159:./src/Main.c  **** //		{
 160:./src/Main.c  **** //			_db_msg(LPC_UART0, "address is good\r\n");
 161:./src/Main.c  **** //
 162:./src/Main.c  **** //			 /* Needed operation. */
 163:./src/Main.c  **** //			*nSymFunc = mainPointer + 1;
 164:./src/Main.c  **** //
 165:./src/Main.c  **** //			 /* ~Protection from typing s symbol. */
 166:./src/Main.c  **** //			pbit->adrDone = true;
 167:./src/Main.c  **** //			myStat = checkingCommand;
 168:./src/Main.c  **** //		}
 169:./src/Main.c  **** //		else
 170:./src/Main.c  **** //		{
 171:./src/Main.c  **** //			myStat = doNothing;
 172:./src/Main.c  **** //
 173:./src/Main.c  **** //			pbit->start = false;
 174:./src/Main.c  **** //			_db_msg(LPC_UART0, " Address is invalid\r\n");
 175:./src/Main.c  **** //		}
 176:./src/Main.c  **** //	}
 177:./src/Main.c  **** //}
 178:./src/Main.c  **** 
 179:./src/Main.c  **** void
 180:./src/Main.c  **** addrCheck(volatile char* pBuf)
 181:./src/Main.c  **** {
  44              		.loc 1 181 0
  45              		.cfi_startproc
  46              		@ args = 0, pretend = 0, frame = 0
  47              		@ frame_needed = 0, uses_anonymous_args = 0
  48              	.LVL0:
  49              		.loc 1 181 0
  50 0000 38B5     		push	{r3, r4, r5, lr}
  51              		.cfi_def_cfa_offset 16
  52              		.cfi_offset 3, -16
  53              		.cfi_offset 4, -12
  54              		.cfi_offset 5, -8
  55              		.cfi_offset 14, -4
 182:./src/Main.c  **** 	switch (n)
  56              		.loc 1 182 0
  57 0002 1E4B     		ldr	r3, .L13
  58 0004 1B88     		ldrh	r3, [r3]
  59 0006 9BB2     		uxth	r3, r3
  60 0008 012B     		cmp	r3, #1
  61 000a 14D0     		beq	.L4
  62 000c 022B     		cmp	r3, #2
  63 000e 11D1     		bne	.L11
 183:./src/Main.c  **** 	{
 184:./src/Main.c  **** 	case 1:
 185:./src/Main.c  **** 		if (*pBuf != MB_ADDRESS_SLAVE_1)
 186:./src/Main.c  **** 			{
 187:./src/Main.c  **** 			/* Можно и doNothing, хотя ...*/
 188:./src/Main.c  **** 				myStat = clearing;
 189:./src/Main.c  **** 				pbit->start = false;
 190:./src/Main.c  **** 				_db_msg(LPC_UART0," Address is invalid\r\n");
 191:./src/Main.c  **** 			}
 192:./src/Main.c  **** 		break;
 193:./src/Main.c  **** 
 194:./src/Main.c  **** 	case 2:
 195:./src/Main.c  **** 		if (*(pBuf + 1) == MB_ADDRESS_SLAVE_2)
  64              		.loc 1 195 0
  65 0010 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
  66 0012 312B     		cmp	r3, #49
  67 0014 20D0     		beq	.L12
 196:./src/Main.c  **** 		{
 197:./src/Main.c  **** 			_db_msg(LPC_UART0, "address is good\r\n");
 198:./src/Main.c  **** 
 199:./src/Main.c  **** 			 /* Needed operation. */
 200:./src/Main.c  **** 			mainPointer = 3;
 201:./src/Main.c  **** 
 202:./src/Main.c  **** 			 /* ~Protection from typing s symbol. */
 203:./src/Main.c  **** 			pbit->adrDone = true;
 204:./src/Main.c  **** 			myStat = checkingCommand;
 205:./src/Main.c  **** 		}
 206:./src/Main.c  **** 		else
 207:./src/Main.c  **** 		{
 208:./src/Main.c  **** 			/* Можно и doNothing, хотя ...*/
 209:./src/Main.c  **** 			myStat = clearing;
 210:./src/Main.c  **** 
 211:./src/Main.c  **** 			pbit->start = false;
  68              		.loc 1 211 0
  69 0016 1A4B     		ldr	r3, .L13+4
 209:./src/Main.c  **** 			myStat = clearing;
  70              		.loc 1 209 0
  71 0018 1A4A     		ldr	r2, .L13+8
  72              		.loc 1 211 0
  73 001a 1B68     		ldr	r3, [r3]
 209:./src/Main.c  **** 			myStat = clearing;
  74              		.loc 1 209 0
  75 001c 0121     		movs	r1, #1
  76 001e 1170     		strb	r1, [r2]
  77              		.loc 1 211 0
  78 0020 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 212:./src/Main.c  **** 			_db_msg(LPC_UART0," Address is invalid\r\n");
  79              		.loc 1 212 0
  80 0022 1949     		ldr	r1, .L13+12
 211:./src/Main.c  **** 			pbit->start = false;
  81              		.loc 1 211 0
  82 0024 6FF30002 		bfc	r2, #0, #1
  83 0028 1A70     		strb	r2, [r3]
  84              		.loc 1 212 0
  85 002a 1848     		ldr	r0, .L13+16
  86              	.LVL1:
  87 002c 0B68     		ldr	r3, [r1]
  88 002e 1849     		ldr	r1, .L13+20
  89 0030 9847     		blx	r3
  90              	.LVL2:
  91              	.L2:
  92 0032 38BD     		pop	{r3, r4, r5, pc}
  93              	.LVL3:
  94              	.L11:
  95 0034 38BD     		pop	{r3, r4, r5, pc}
  96              	.L4:
 185:./src/Main.c  **** 		if (*pBuf != MB_ADDRESS_SLAVE_1)
  97              		.loc 1 185 0
  98 0036 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
  99 0038 302A     		cmp	r2, #48
 100 003a FAD0     		beq	.L2
 189:./src/Main.c  **** 				pbit->start = false;
 101              		.loc 1 189 0
 102 003c 104A     		ldr	r2, .L13+4
 188:./src/Main.c  **** 				myStat = clearing;
 103              		.loc 1 188 0
 104 003e 1149     		ldr	r1, .L13+8
 189:./src/Main.c  **** 				pbit->start = false;
 105              		.loc 1 189 0
 106 0040 1268     		ldr	r2, [r2]
 188:./src/Main.c  **** 				myStat = clearing;
 107              		.loc 1 188 0
 108 0042 0B70     		strb	r3, [r1]
 189:./src/Main.c  **** 				pbit->start = false;
 109              		.loc 1 189 0
 110 0044 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 190:./src/Main.c  **** 				_db_msg(LPC_UART0," Address is invalid\r\n");
 111              		.loc 1 190 0
 112 0046 1049     		ldr	r1, .L13+12
 189:./src/Main.c  **** 				pbit->start = false;
 113              		.loc 1 189 0
 114 0048 6FF30003 		bfc	r3, #0, #1
 115 004c 1370     		strb	r3, [r2]
 190:./src/Main.c  **** 				_db_msg(LPC_UART0," Address is invalid\r\n");
 116              		.loc 1 190 0
 117 004e 0F48     		ldr	r0, .L13+16
 118              	.LVL4:
 119 0050 0B68     		ldr	r3, [r1]
 120 0052 0F49     		ldr	r1, .L13+20
 121 0054 9847     		blx	r3
 122              	.LVL5:
 123 0056 38BD     		pop	{r3, r4, r5, pc}
 124              	.LVL6:
 125              	.L12:
 197:./src/Main.c  **** 			_db_msg(LPC_UART0, "address is good\r\n");
 126              		.loc 1 197 0
 127 0058 0B4B     		ldr	r3, .L13+12
 128 005a 0C48     		ldr	r0, .L13+16
 129              	.LVL7:
 130 005c 1B68     		ldr	r3, [r3]
 131 005e 0D49     		ldr	r1, .L13+24
 132 0060 9847     		blx	r3
 133              	.LVL8:
 203:./src/Main.c  **** 			pbit->adrDone = true;
 134              		.loc 1 203 0
 135 0062 074B     		ldr	r3, .L13+4
 200:./src/Main.c  **** 			mainPointer = 3;
 136              		.loc 1 200 0
 137 0064 0C48     		ldr	r0, .L13+28
 203:./src/Main.c  **** 			pbit->adrDone = true;
 138              		.loc 1 203 0
 139 0066 1B68     		ldr	r3, [r3]
 204:./src/Main.c  **** 			myStat = checkingCommand;
 140              		.loc 1 204 0
 141 0068 064A     		ldr	r2, .L13+8
 203:./src/Main.c  **** 			pbit->adrDone = true;
 142              		.loc 1 203 0
 143 006a 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 200:./src/Main.c  **** 			mainPointer = 3;
 144              		.loc 1 200 0
 145 006c 0324     		movs	r4, #3
 203:./src/Main.c  **** 			pbit->adrDone = true;
 146              		.loc 1 203 0
 147 006e 45F00205 		orr	r5, r5, #2
 204:./src/Main.c  **** 			myStat = checkingCommand;
 148              		.loc 1 204 0
 149 0072 0421     		movs	r1, #4
 203:./src/Main.c  **** 			pbit->adrDone = true;
 150              		.loc 1 203 0
 151 0074 1D70     		strb	r5, [r3]
 200:./src/Main.c  **** 			mainPointer = 3;
 152              		.loc 1 200 0
 153 0076 0480     		strh	r4, [r0]	@ movhi
 204:./src/Main.c  **** 			myStat = checkingCommand;
 154              		.loc 1 204 0
 155 0078 1170     		strb	r1, [r2]
 156 007a 38BD     		pop	{r3, r4, r5, pc}
 157              	.L14:
 158              		.align	2
 159              	.L13:
 160 007c 00000000 		.word	.LANCHOR0
 161 0080 00000000 		.word	.LANCHOR1
 162 0084 00000000 		.word	myStat
 163 0088 00000000 		.word	_db_msg
 164 008c 00C00040 		.word	1073790976
 165 0090 00000000 		.word	.LC0
 166 0094 18000000 		.word	.LC1
 167 0098 00000000 		.word	.LANCHOR2
 168              		.cfi_endproc
 169              	.LFE57:
 171              		.section	.text.receivingHandler,"ax",%progbits
 172              		.align	2
 173              		.global	receivingHandler
 174              		.thumb
 175              		.thumb_func
 177              	receivingHandler:
 178              	.LFB59:
 213:./src/Main.c  **** 		}
 214:./src/Main.c  **** 		break;
 215:./src/Main.c  **** 	default:
 216:./src/Main.c  **** 		break;
 217:./src/Main.c  **** 	}
 218:./src/Main.c  **** }
 219:./src/Main.c  **** 
 220:./src/Main.c  **** inline
 221:./src/Main.c  **** UCHAR MBCHAR2BIN()
 222:./src/Main.c  **** {
 223:./src/Main.c  **** 	return 10*(Buf[0] -'0') + (Buf[1] -'0');
 224:./src/Main.c  **** }
 225:./src/Main.c  **** 
 226:./src/Main.c  **** void
 227:./src/Main.c  **** receivingHandler(void)
 228:./src/Main.c  **** {
 179              		.loc 1 228 0
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 0, uses_anonymous_args = 0
 183 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 184              		.cfi_def_cfa_offset 24
 185              		.cfi_offset 3, -24
 186              		.cfi_offset 4, -20
 187              		.cfi_offset 5, -16
 188              		.cfi_offset 6, -12
 189              		.cfi_offset 7, -8
 190              		.cfi_offset 14, -4
 229:./src/Main.c  **** 	ch = UARTGetChar(LPC_UART0);
 191              		.loc 1 229 0
 192 0002 6A48     		ldr	r0, .L55
 193 0004 FFF7FEFF 		bl	UARTGetChar
 194              	.LVL9:
 195 0008 694C     		ldr	r4, .L55+4
 196 000a 2070     		strb	r0, [r4]
 230:./src/Main.c  **** 	switch (ch)
 197              		.loc 1 230 0
 198 000c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 199 000e DBB2     		uxtb	r3, r3
 200 0010 532B     		cmp	r3, #83
 201 0012 33D0     		beq	.L17
 202 0014 732B     		cmp	r3, #115
 203 0016 31D0     		beq	.L17
 204 0018 0D2B     		cmp	r3, #13
 205 001a 29D0     		beq	.L50
 231:./src/Main.c  **** 	{
 232:./src/Main.c  **** 		case 'S':
 233:./src/Main.c  **** 			/* break;
 234:./src/Main.c  **** 			 * Специально закоментированный break. */
 235:./src/Main.c  **** 		case 's':
 236:./src/Main.c  **** 			if (!(pbit->adrDone))
 237:./src/Main.c  **** 			{
 238:./src/Main.c  **** 				byte.allFlags = 0;
 239:./src/Main.c  **** 				/* Специально подчеркиваю что это начало.
 240:./src/Main.c  **** 				 * Можно byte.allFlags = 1. */
 241:./src/Main.c  **** 				pbit->start = true;
 242:./src/Main.c  **** 				pCom = &CommList[0];
 243:./src/Main.c  **** 				n=0;
 244:./src/Main.c  **** 				mainPointer = 0;
 245:./src/Main.c  **** 				myStat = checkingAddress;
 246:./src/Main.c  **** 				_db_msg(LPC_UART0, "session_started\r\n");
 247:./src/Main.c  **** 			}
 248:./src/Main.c  **** 			else
 249:./src/Main.c  **** 			{
 250:./src/Main.c  **** 				/* Защита от второго начала команды s01. */
 251:./src/Main.c  **** 				pbit->secondS = true;
 252:./src/Main.c  **** 				/* Защита от второго начала команды s01. */
 253:./src/Main.c  **** 
 254:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nSecondSSS \r\n");
 255:./src/Main.c  **** 				if (ch >= 'a' && ch <='z' && !pbit->comDone) ch = ch - 32;
 256:./src/Main.c  **** 				Buf[n++] = ch;
 257:./src/Main.c  **** 			}
 258:./src/Main.c  **** 			break;
 259:./src/Main.c  **** 		case '\r':
 260:./src/Main.c  **** 			if (pbit->start)
 261:./src/Main.c  **** 				{
 262:./src/Main.c  **** 					_db_msg(LPC_UART0, "\r\nsession_finished\r\n");
 263:./src/Main.c  **** 					byte.allFlags = 0;
 264:./src/Main.c  **** 					myStat = executing;
 265:./src/Main.c  **** 				}
 266:./src/Main.c  **** 			break;
 267:./src/Main.c  **** 		default:
 268:./src/Main.c  **** 			if (pbit->start)
 206              		.loc 1 268 0
 207 001c 654B     		ldr	r3, .L55+8
 208 001e 1B68     		ldr	r3, [r3]
 209 0020 1A68     		ldr	r2, [r3]
 210 0022 D207     		lsls	r2, r2, #31
 211 0024 29D5     		bpl	.L15
 269:./src/Main.c  **** 			{
 270:./src/Main.c  **** 				if (ch >= 'a' && ch <='z' && !pbit->comDone)  ch = ch - 32;
 212              		.loc 1 270 0
 213 0026 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 214 0028 602A     		cmp	r2, #96
 215 002a 09D9     		bls	.L22
 216              		.loc 1 270 0 is_stmt 0 discriminator 1
 217 002c 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 218 002e 7A2A     		cmp	r2, #122
 219 0030 06D8     		bhi	.L22
 220 0032 1A68     		ldr	r2, [r3]
 221 0034 5707     		lsls	r7, r2, #29
 222 0036 03D4     		bmi	.L22
 223 0038 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 224 003a 203A     		subs	r2, r2, #32
 225 003c D2B2     		uxtb	r2, r2
 226 003e 2270     		strb	r2, [r4]
 227              	.L22:
 271:./src/Main.c  **** 
 272:./src/Main.c  **** 
 273:./src/Main.c  **** 				/* Защита от второго начала команды s01. */
 274:./src/Main.c  **** 				if ((!(ch >= '0' && ch <= '9') && pbit->secondS))
 228              		.loc 1 274 0 is_stmt 1
 229 0040 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 230 0042 5B49     		ldr	r1, .L55+4
 231 0044 2F2A     		cmp	r2, #47
 232 0046 43D9     		bls	.L23
 233              		.loc 1 274 0 is_stmt 0 discriminator 2
 234 0048 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 235 004a 392A     		cmp	r2, #57
 236 004c 40D8     		bhi	.L23
 237              	.L24:
 275:./src/Main.c  **** 				{
 276:./src/Main.c  **** 					pbit->secondN = true;
 277:./src/Main.c  **** 					pbit->secondS = false;
 278:./src/Main.c  **** 				}
 279:./src/Main.c  **** 				else if (ch == MB_ADDRESS_SLAVE_1 && !pbit->secondN && pbit->secondS)
 238              		.loc 1 279 0 is_stmt 1
 239 004e 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 240 0050 302A     		cmp	r2, #48
 241 0052 79D0     		beq	.L51
 242              	.L26:
 280:./src/Main.c  **** 					{
 281:./src/Main.c  **** 						//pbit->secondN = true;
 282:./src/Main.c  **** 						_db_msg(LPC_UART0, "\r\nSSS - First \r\n");
 283:./src/Main.c  **** 					}
 284:./src/Main.c  **** 					else if (ch == MB_ADDRESS_SLAVE_2 && !pbit->secondN && pbit->secondS)
 243              		.loc 1 284 0
 244 0054 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 245 0056 312A     		cmp	r2, #49
 246 0058 00F08480 		beq	.L52
 247              	.L27:
 285:./src/Main.c  **** 					{
 286:./src/Main.c  **** 						byte.allFlags = 0;
 287:./src/Main.c  **** 						/* Специально подчеркиваю что это начало.
 288:./src/Main.c  **** 						 * Можно byte.allFlags = 1. */
 289:./src/Main.c  **** 						pbit->start = true;
 290:./src/Main.c  **** 						n = 1;
 291:./src/Main.c  **** 						pbit->secondN = true;
 292:./src/Main.c  **** 						pbit->secondS = false;
 293:./src/Main.c  **** 						myStat = iniSecondsS;
 294:./src/Main.c  **** 						_db_msg(LPC_UART0, "\r\nSSS - Second \r\n");
 295:./src/Main.c  **** 					}
 296:./src/Main.c  **** 					else
 297:./src/Main.c  **** 					{
 298:./src/Main.c  **** 						pbit->secondS = false;
 248              		.loc 1 298 0
 249 005c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 250 005e 564D     		ldr	r5, .L55+12
 251 0060 6FF30412 		bfc	r2, #4, #1
 252 0064 1A70     		strb	r2, [r3]
 299:./src/Main.c  **** 						pbit->secondN = true;
 253              		.loc 1 299 0
 254 0066 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 255 0068 42F02002 		orr	r2, r2, #32
 256 006c 1A70     		strb	r2, [r3]
 257 006e 3BE0     		b	.L25
 258              	.L50:
 260:./src/Main.c  **** 			if (pbit->start)
 259              		.loc 1 260 0
 260 0070 504B     		ldr	r3, .L55+8
 261 0072 1B68     		ldr	r3, [r3]
 262 0074 1B68     		ldr	r3, [r3]
 263 0076 D907     		lsls	r1, r3, #31
 264 0078 5AD4     		bmi	.L53
 265              	.L15:
 266 007a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 267              	.L17:
 236:./src/Main.c  **** 			if (!(pbit->adrDone))
 268              		.loc 1 236 0
 269 007c 4D4D     		ldr	r5, .L55+8
 270 007e 2B68     		ldr	r3, [r5]
 271 0080 1A68     		ldr	r2, [r3]
 272 0082 C2F34002 		ubfx	r2, r2, #1, #1
 273 0086 002A     		cmp	r2, #0
 274 0088 38D0     		beq	.L54
 251:./src/Main.c  **** 				pbit->secondS = true;
 275              		.loc 1 251 0
 276 008a 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 254:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nSecondSSS \r\n");
 277              		.loc 1 254 0
 278 008c 4B4A     		ldr	r2, .L55+16
 251:./src/Main.c  **** 				pbit->secondS = true;
 279              		.loc 1 251 0
 280 008e 41F01001 		orr	r1, r1, #16
 281 0092 1970     		strb	r1, [r3]
 254:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nSecondSSS \r\n");
 282              		.loc 1 254 0
 283 0094 4548     		ldr	r0, .L55
 284 0096 1368     		ldr	r3, [r2]
 285 0098 4949     		ldr	r1, .L55+20
 286 009a 9847     		blx	r3
 287              	.LVL10:
 255:./src/Main.c  **** 				if (ch >= 'a' && ch <='z' && !pbit->comDone) ch = ch - 32;
 288              		.loc 1 255 0
 289 009c 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 290 009e 444B     		ldr	r3, .L55+4
 291 00a0 602A     		cmp	r2, #96
 292 00a2 0AD9     		bls	.L21
 255:./src/Main.c  **** 				if (ch >= 'a' && ch <='z' && !pbit->comDone) ch = ch - 32;
 293              		.loc 1 255 0 is_stmt 0 discriminator 1
 294 00a4 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 295 00a6 7A2A     		cmp	r2, #122
 296 00a8 07D8     		bhi	.L21
 297 00aa 2A68     		ldr	r2, [r5]
 298 00ac 1268     		ldr	r2, [r2]
 299 00ae 5007     		lsls	r0, r2, #29
 300 00b0 03D4     		bmi	.L21
 301 00b2 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 302 00b4 203A     		subs	r2, r2, #32
 303 00b6 D2B2     		uxtb	r2, r2
 304 00b8 1A70     		strb	r2, [r3]
 305              	.L21:
 256:./src/Main.c  **** 				Buf[n++] = ch;
 306              		.loc 1 256 0 is_stmt 1
 307 00ba 3F4A     		ldr	r2, .L55+12
 308 00bc 4149     		ldr	r1, .L55+24
 309 00be 1388     		ldrh	r3, [r2]
 310 00c0 9BB2     		uxth	r3, r3
 311 00c2 581C     		adds	r0, r3, #1
 312 00c4 80B2     		uxth	r0, r0
 313 00c6 1080     		strh	r0, [r2]	@ movhi
 314 00c8 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 315 00ca D2B2     		uxtb	r2, r2
 316 00cc CA54     		strb	r2, [r1, r3]
 317 00ce F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 318              	.L23:
 274:./src/Main.c  **** 				if ((!(ch >= '0' && ch <= '9') && pbit->secondS))
 319              		.loc 1 274 0 discriminator 1
 320 00d0 1A68     		ldr	r2, [r3]
 321 00d2 D606     		lsls	r6, r2, #27
 322 00d4 BBD5     		bpl	.L24
 276:./src/Main.c  **** 					pbit->secondN = true;
 323              		.loc 1 276 0
 324 00d6 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 325 00d8 374D     		ldr	r5, .L55+12
 326 00da 42F02002 		orr	r2, r2, #32
 327 00de 1A70     		strb	r2, [r3]
 277:./src/Main.c  **** 					pbit->secondS = false;
 328              		.loc 1 277 0
 329 00e0 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 330 00e2 6FF30412 		bfc	r2, #4, #1
 331 00e6 1A70     		strb	r2, [r3]
 332              	.L25:
 300:./src/Main.c  **** 					}
 301:./src/Main.c  **** 				 /* Защита от второго начала команды s01. */
 302:./src/Main.c  **** 
 303:./src/Main.c  **** 
 304:./src/Main.c  **** 				Buf[n++] = ch;
 333              		.loc 1 304 0
 334 00e8 2B88     		ldrh	r3, [r5]
 335 00ea 364A     		ldr	r2, .L55+24
 336 00ec 9BB2     		uxth	r3, r3
 337 00ee 591C     		adds	r1, r3, #1
 338 00f0 89B2     		uxth	r1, r1
 339 00f2 2980     		strh	r1, [r5]	@ movhi
 340 00f4 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 341 00f6 C9B2     		uxtb	r1, r1
 342 00f8 D154     		strb	r1, [r2, r3]
 343 00fa F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 344              	.L54:
 238:./src/Main.c  **** 				byte.allFlags = 0;
 345              		.loc 1 238 0
 346 00fc 3249     		ldr	r1, .L55+28
 243:./src/Main.c  **** 				n=0;
 347              		.loc 1 243 0
 348 00fe 2E4F     		ldr	r7, .L55+12
 238:./src/Main.c  **** 				byte.allFlags = 0;
 349              		.loc 1 238 0
 350 0100 0A70     		strb	r2, [r1]
 241:./src/Main.c  **** 				pbit->start = true;
 351              		.loc 1 241 0
 352 0102 93F800C0 		ldrb	ip, [r3]	@ zero_extendqisi2
 242:./src/Main.c  **** 				pCom = &CommList[0];
 353              		.loc 1 242 0
 354 0106 314D     		ldr	r5, .L55+32
 355 0108 314E     		ldr	r6, .L55+36
 245:./src/Main.c  **** 				myStat = checkingAddress;
 356              		.loc 1 245 0
 357 010a 3249     		ldr	r1, .L55+40
 246:./src/Main.c  **** 				_db_msg(LPC_UART0, "session_started\r\n");
 358              		.loc 1 246 0
 359 010c DFF8ACE0 		ldr	lr, .L55+16
 241:./src/Main.c  **** 				pbit->start = true;
 360              		.loc 1 241 0
 361 0110 4CF0010C 		orr	ip, ip, #1
 245:./src/Main.c  **** 				myStat = checkingAddress;
 362              		.loc 1 245 0
 363 0114 0220     		movs	r0, #2
 244:./src/Main.c  **** 				mainPointer = 0;
 364              		.loc 1 244 0
 365 0116 304C     		ldr	r4, .L55+44
 241:./src/Main.c  **** 				pbit->start = true;
 366              		.loc 1 241 0
 367 0118 83F800C0 		strb	ip, [r3]
 243:./src/Main.c  **** 				n=0;
 368              		.loc 1 243 0
 369 011c 3A80     		strh	r2, [r7]	@ movhi
 246:./src/Main.c  **** 				_db_msg(LPC_UART0, "session_started\r\n");
 370              		.loc 1 246 0
 371 011e DEF80030 		ldr	r3, [lr]
 245:./src/Main.c  **** 				myStat = checkingAddress;
 372              		.loc 1 245 0
 373 0122 0870     		strb	r0, [r1]
 242:./src/Main.c  **** 				pCom = &CommList[0];
 374              		.loc 1 242 0
 375 0124 2E60     		str	r6, [r5]
 246:./src/Main.c  **** 				_db_msg(LPC_UART0, "session_started\r\n");
 376              		.loc 1 246 0
 377 0126 2148     		ldr	r0, .L55
 378 0128 2C49     		ldr	r1, .L55+48
 244:./src/Main.c  **** 				mainPointer = 0;
 379              		.loc 1 244 0
 380 012a 2280     		strh	r2, [r4]	@ movhi
 246:./src/Main.c  **** 				_db_msg(LPC_UART0, "session_started\r\n");
 381              		.loc 1 246 0
 382 012c 9847     		blx	r3
 383              	.LVL11:
 384 012e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 385              	.L53:
 262:./src/Main.c  **** 					_db_msg(LPC_UART0, "\r\nsession_finished\r\n");
 386              		.loc 1 262 0
 387 0130 224B     		ldr	r3, .L55+16
 388 0132 1E48     		ldr	r0, .L55
 389 0134 1B68     		ldr	r3, [r3]
 390 0136 2A49     		ldr	r1, .L55+52
 391 0138 9847     		blx	r3
 392              	.LVL12:
 263:./src/Main.c  **** 					byte.allFlags = 0;
 393              		.loc 1 263 0
 394 013a 2349     		ldr	r1, .L55+28
 264:./src/Main.c  **** 					myStat = executing;
 395              		.loc 1 264 0
 396 013c 254B     		ldr	r3, .L55+40
 263:./src/Main.c  **** 					byte.allFlags = 0;
 397              		.loc 1 263 0
 398 013e 0020     		movs	r0, #0
 264:./src/Main.c  **** 					myStat = executing;
 399              		.loc 1 264 0
 400 0140 0622     		movs	r2, #6
 263:./src/Main.c  **** 					byte.allFlags = 0;
 401              		.loc 1 263 0
 402 0142 0870     		strb	r0, [r1]
 264:./src/Main.c  **** 					myStat = executing;
 403              		.loc 1 264 0
 404 0144 1A70     		strb	r2, [r3]
 405 0146 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 406              	.L51:
 279:./src/Main.c  **** 				else if (ch == MB_ADDRESS_SLAVE_1 && !pbit->secondN && pbit->secondS)
 407              		.loc 1 279 0 discriminator 1
 408 0148 1A68     		ldr	r2, [r3]
 409 014a 9506     		lsls	r5, r2, #26
 410 014c 82D4     		bmi	.L26
 411 014e 1A68     		ldr	r2, [r3]
 412 0150 D006     		lsls	r0, r2, #27
 413 0152 7FF57FAF 		bpl	.L26
 282:./src/Main.c  **** 						_db_msg(LPC_UART0, "\r\nSSS - First \r\n");
 414              		.loc 1 282 0
 415 0156 194B     		ldr	r3, .L55+16
 416 0158 1448     		ldr	r0, .L55
 417 015a 1B68     		ldr	r3, [r3]
 418 015c 2149     		ldr	r1, .L55+56
 419 015e 9847     		blx	r3
 420              	.LVL13:
 421 0160 154D     		ldr	r5, .L55+12
 422 0162 C1E7     		b	.L25
 423              	.L52:
 284:./src/Main.c  **** 					else if (ch == MB_ADDRESS_SLAVE_2 && !pbit->secondN && pbit->secondS)
 424              		.loc 1 284 0 discriminator 1
 425 0164 1A68     		ldr	r2, [r3]
 426 0166 C2F34012 		ubfx	r2, r2, #5, #1
 427 016a 002A     		cmp	r2, #0
 428 016c 7FF476AF 		bne	.L27
 429 0170 1968     		ldr	r1, [r3]
 430 0172 C906     		lsls	r1, r1, #27
 431 0174 7FF572AF 		bpl	.L27
 286:./src/Main.c  **** 						byte.allFlags = 0;
 432              		.loc 1 286 0
 433 0178 1349     		ldr	r1, .L55+28
 290:./src/Main.c  **** 						n = 1;
 434              		.loc 1 290 0
 435 017a 0F4D     		ldr	r5, .L55+12
 286:./src/Main.c  **** 						byte.allFlags = 0;
 436              		.loc 1 286 0
 437 017c 0A70     		strb	r2, [r1]
 289:./src/Main.c  **** 						pbit->start = true;
 438              		.loc 1 289 0
 439 017e 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 290:./src/Main.c  **** 						n = 1;
 440              		.loc 1 290 0
 441 0180 0121     		movs	r1, #1
 289:./src/Main.c  **** 						pbit->start = true;
 442              		.loc 1 289 0
 443 0182 0843     		orrs	r0, r0, r1
 444 0184 1870     		strb	r0, [r3]
 290:./src/Main.c  **** 						n = 1;
 445              		.loc 1 290 0
 446 0186 2980     		strh	r1, [r5]	@ movhi
 291:./src/Main.c  **** 						pbit->secondN = true;
 447              		.loc 1 291 0
 448 0188 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 293:./src/Main.c  **** 						myStat = iniSecondsS;
 449              		.loc 1 293 0
 450 018a 1248     		ldr	r0, .L55+40
 291:./src/Main.c  **** 						pbit->secondN = true;
 451              		.loc 1 291 0
 452 018c 41F02001 		orr	r1, r1, #32
 453 0190 1970     		strb	r1, [r3]
 292:./src/Main.c  **** 						pbit->secondS = false;
 454              		.loc 1 292 0
 455 0192 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 294:./src/Main.c  **** 						_db_msg(LPC_UART0, "\r\nSSS - Second \r\n");
 456              		.loc 1 294 0
 457 0194 094E     		ldr	r6, .L55+16
 292:./src/Main.c  **** 						pbit->secondS = false;
 458              		.loc 1 292 0
 459 0196 62F30411 		bfi	r1, r2, #4, #1
 293:./src/Main.c  **** 						myStat = iniSecondsS;
 460              		.loc 1 293 0
 461 019a 0322     		movs	r2, #3
 292:./src/Main.c  **** 						pbit->secondS = false;
 462              		.loc 1 292 0
 463 019c 1970     		strb	r1, [r3]
 293:./src/Main.c  **** 						myStat = iniSecondsS;
 464              		.loc 1 293 0
 465 019e 0270     		strb	r2, [r0]
 294:./src/Main.c  **** 						_db_msg(LPC_UART0, "\r\nSSS - Second \r\n");
 466              		.loc 1 294 0
 467 01a0 3368     		ldr	r3, [r6]
 468 01a2 0248     		ldr	r0, .L55
 469 01a4 1049     		ldr	r1, .L55+60
 470 01a6 9847     		blx	r3
 471              	.LVL14:
 472 01a8 9EE7     		b	.L25
 473              	.L56:
 474 01aa 00BF     		.align	2
 475              	.L55:
 476 01ac 00C00040 		.word	1073790976
 477 01b0 00000000 		.word	ch
 478 01b4 00000000 		.word	.LANCHOR1
 479 01b8 00000000 		.word	.LANCHOR0
 480 01bc 00000000 		.word	_db_msg
 481 01c0 40000000 		.word	.LC3
 482 01c4 00000000 		.word	Buf
 483 01c8 00000000 		.word	byte
 484 01cc 00000000 		.word	.LANCHOR3
 485 01d0 00000000 		.word	.LANCHOR4
 486 01d4 00000000 		.word	myStat
 487 01d8 00000000 		.word	.LANCHOR2
 488 01dc 2C000000 		.word	.LC2
 489 01e0 50000000 		.word	.LC4
 490 01e4 68000000 		.word	.LC5
 491 01e8 7C000000 		.word	.LC6
 492              		.cfi_endproc
 493              	.LFE59:
 495              		.section	.text.UART0_IRQHandler,"ax",%progbits
 496              		.align	2
 497              		.global	UART0_IRQHandler
 498              		.thumb
 499              		.thumb_func
 501              	UART0_IRQHandler:
 502              	.LFB56:
 122:./src/Main.c  **** {
 503              		.loc 1 122 0
 504              		.cfi_startproc
 505              		@ args = 0, pretend = 0, frame = 0
 506              		@ frame_needed = 0, uses_anonymous_args = 0
 507              		@ link register save eliminated.
 125:./src/Main.c  **** 	iir = LPC_UART0->IIR;
 508              		.loc 1 125 0
 509 0000 034B     		ldr	r3, .L60
 510 0002 9B68     		ldr	r3, [r3, #8]
 511              	.LVL15:
 127:./src/Main.c  **** 	if ((iir & 0x4) || (iir & 0xC)) {            // RDA or CTI pending
 512              		.loc 1 127 0
 513 0004 13F00C0F 		tst	r3, #12
 514 0008 00D1     		bne	.L59
 515 000a 7047     		bx	lr
 516              	.L59:
 131:./src/Main.c  **** 		receivingHandler();
 517              		.loc 1 131 0
 518 000c FFF7FEBF 		b	receivingHandler
 519              	.LVL16:
 520              	.L61:
 521              		.align	2
 522              	.L60:
 523 0010 00C00040 		.word	1073790976
 524              		.cfi_endproc
 525              	.LFE56:
 527              		.section	.text.Errors,"ax",%progbits
 528              		.align	2
 529              		.global	Errors
 530              		.thumb
 531              		.thumb_func
 533              	Errors:
 534              	.LFB60:
 305:./src/Main.c  **** 			}
 306:./src/Main.c  **** 			break;
 307:./src/Main.c  **** 	}
 308:./src/Main.c  **** }
 309:./src/Main.c  **** 
 310:./src/Main.c  **** 
 311:./src/Main.c  **** void Errors (void)
 312:./src/Main.c  **** {
 535              		.loc 1 312 0
 536              		.cfi_startproc
 537              		@ args = 0, pretend = 0, frame = 0
 538              		@ frame_needed = 0, uses_anonymous_args = 0
 539 0000 08B5     		push	{r3, lr}
 540              		.cfi_def_cfa_offset 8
 541              		.cfi_offset 3, -8
 542              		.cfi_offset 14, -4
 313:./src/Main.c  **** 	_db_msg(LPC_UART0, "\r\nError \r\n");
 543              		.loc 1 313 0
 544 0002 034B     		ldr	r3, .L63
 545 0004 0348     		ldr	r0, .L63+4
 546 0006 1B68     		ldr	r3, [r3]
 547 0008 0349     		ldr	r1, .L63+8
 548 000a 9847     		blx	r3
 549              	.LVL17:
 550 000c 08BD     		pop	{r3, pc}
 551              	.L64:
 552 000e 00BF     		.align	2
 553              	.L63:
 554 0010 00000000 		.word	_db_msg
 555 0014 00C00040 		.word	1073790976
 556 0018 90000000 		.word	.LC7
 557              		.cfi_endproc
 558              	.LFE60:
 560              		.section	.text.Parse,"ax",%progbits
 561              		.align	2
 562              		.global	Parse
 563              		.thumb
 564              		.thumb_func
 566              	Parse:
 567              	.LFB61:
 314:./src/Main.c  **** }
 315:./src/Main.c  **** 
 316:./src/Main.c  **** uint16_t
 317:./src/Main.c  **** Parse (volatile char* pBuf, uint16_t nChCom, uint16_t *nMatchCommand)
 318:./src/Main.c  **** {
 568              		.loc 1 318 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 0
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572              		@ link register save eliminated.
 573              	.LVL18:
 574 0000 DFF8B8C0 		ldr	ip, .L82+4
 575 0004 2DE9F003 		push	{r4, r5, r6, r7, r8, r9}
 576              		.cfi_def_cfa_offset 24
 577              		.cfi_offset 4, -24
 578              		.cfi_offset 5, -20
 579              		.cfi_offset 6, -16
 580              		.cfi_offset 7, -12
 581              		.cfi_offset 8, -8
 582              		.cfi_offset 9, -4
 583 0008 6346     		mov	r3, ip
 319:./src/Main.c  **** 	uint16_t nMatches = 0;
 320:./src/Main.c  **** 	/* Обязательно ставим 1, так как 0-ой необходим для указания ошибки. */
 321:./src/Main.c  **** 	uint16_t iStr = 1;	//var to brute
 322:./src/Main.c  **** 
 323:./src/Main.c  **** 	while(iStr < N)  //brute force all commands by 1 character								//changed N to 3
 324:./src/Main.c  **** 	{
 325:./src/Main.c  **** 
 326:./src/Main.c  **** 		if (*pBuf == CommList[iStr].name[nChCom] && CommList[iStr].flag == nChCom)
 327:./src/Main.c  **** 
 328:./src/Main.c  **** 		{
 329:./src/Main.c  **** 			CommList[iStr].flag = nChCom + 1;
 584              		.loc 1 329 0
 585 000a 01F10109 		add	r9, r1, #1
 321:./src/Main.c  **** 	uint16_t iStr = 1;	//var to brute
 586              		.loc 1 321 0
 587 000e 0124     		movs	r4, #1
 319:./src/Main.c  **** 	uint16_t nMatches = 0;
 588              		.loc 1 319 0
 589 0010 4FF00008 		mov	r8, #0
 590 0014 04E0     		b	.L68
 591              	.LVL19:
 592              	.L66:
 330:./src/Main.c  **** 
 331:./src/Main.c  **** 			*(nMatchCommand + nMatches) = iStr;
 332:./src/Main.c  **** 			nMatches++;
 333:./src/Main.c  **** 		}
 334:./src/Main.c  **** 		iStr++;
 593              		.loc 1 334 0
 594 0016 ACB2     		uxth	r4, r5
 595              	.LVL20:
 323:./src/Main.c  **** 	while(iStr < N)  //brute force all commands by 1 character								//changed N to 3
 596              		.loc 1 323 0
 597 0018 322C     		cmp	r4, #50
 598 001a 03F11D03 		add	r3, r3, #29
 599 001e 15D0     		beq	.L79
 600              	.LVL21:
 601              	.L68:
 602 0020 5D18     		adds	r5, r3, r1
 326:./src/Main.c  **** 		if (*pBuf == CommList[iStr].name[nChCom] && CommList[iStr].flag == nChCom)
 603              		.loc 1 326 0
 604 0022 EF7F     		ldrb	r7, [r5, #31]	@ zero_extendqisi2
 605 0024 0678     		ldrb	r6, [r0]	@ zero_extendqisi2
 606              		.loc 1 334 0
 607 0026 651C     		adds	r5, r4, #1
 326:./src/Main.c  **** 		if (*pBuf == CommList[iStr].name[nChCom] && CommList[iStr].flag == nChCom)
 608              		.loc 1 326 0
 609 0028 B742     		cmp	r7, r6
 610 002a F4D1     		bne	.L66
 326:./src/Main.c  **** 		if (*pBuf == CommList[iStr].name[nChCom] && CommList[iStr].flag == nChCom)
 611              		.loc 1 326 0 is_stmt 0 discriminator 1
 612 002c 9E7F     		ldrb	r6, [r3, #30]	@ zero_extendqisi2
 613 002e 8E42     		cmp	r6, r1
 614 0030 F1D1     		bne	.L66
 329:./src/Main.c  **** 			CommList[iStr].flag = nChCom + 1;
 615              		.loc 1 329 0 is_stmt 1
 616 0032 83F81E90 		strb	r9, [r3, #30]
 331:./src/Main.c  **** 			*(nMatchCommand + nMatches) = iStr;
 617              		.loc 1 331 0
 618 0036 22F81840 		strh	r4, [r2, r8, lsl #1]	@ movhi
 619              		.loc 1 334 0
 620 003a ACB2     		uxth	r4, r5
 621              	.LVL22:
 332:./src/Main.c  **** 			nMatches++;
 622              		.loc 1 332 0
 623 003c 08F10106 		add	r6, r8, #1
 323:./src/Main.c  **** 	while(iStr < N)  //brute force all commands by 1 character								//changed N to 3
 624              		.loc 1 323 0
 625 0040 322C     		cmp	r4, #50
 332:./src/Main.c  **** 			nMatches++;
 626              		.loc 1 332 0
 627 0042 1FFA86F8 		uxth	r8, r6
 628              	.LVL23:
 629 0046 03F11D03 		add	r3, r3, #29
 323:./src/Main.c  **** 	while(iStr < N)  //brute force all commands by 1 character								//changed N to 3
 630              		.loc 1 323 0
 631 004a E9D1     		bne	.L68
 632              	.LVL24:
 633              	.L79:
 335:./src/Main.c  **** 	}
 336:./src/Main.c  **** 	/* Анализируем количество. */
 337:./src/Main.c  **** 	if (nMatches != 0)
 634              		.loc 1 337 0
 635 004c B8F1000F 		cmp	r8, #0
 636 0050 1CD0     		beq	.L69
 637              	.LVL25:
 338:./src/Main.c  **** 	{
 339:./src/Main.c  **** 		iStr = 0;
 340:./src/Main.c  **** 		while(iStr < nMatches)
 341:./src/Main.c  **** 		{
 342:./src/Main.c  **** 
 343:./src/Main.c  **** 			if ((nChCom + 1) == (uint16_t) CommList[*nMatchCommand + iStr].length)
 638              		.loc 1 343 0 discriminator 1
 639 0052 1388     		ldrh	r3, [r2]
 640 0054 0131     		adds	r1, r1, #1
 641              	.LVL26:
 642 0056 C3EBC305 		rsb	r5, r3, r3, lsl #3
 643 005a 03EB8505 		add	r5, r3, r5, lsl #2
 644 005e 0CEB0500 		add	r0, ip, r5
 645              	.LVL27:
 646 0062 C47E     		ldrb	r4, [r0, #27]	@ zero_extendqisi2
 647 0064 A142     		cmp	r1, r4
 648 0066 25D0     		beq	.L80
 649 0068 6FF01C06 		mvn	r6, #28
 650 006c 06FB03F6 		mul	r6, r6, r3
 651              		.loc 1 343 0 is_stmt 0
 652 0070 0023     		movs	r3, #0
 653 0072 03E0     		b	.L73
 654              	.LVL28:
 655              	.L75:
 656 0074 94F83840 		ldrb	r4, [r4, #56]	@ zero_extendqisi2
 657 0078 8C42     		cmp	r4, r1
 658 007a 0ED0     		beq	.L81
 659              	.LVL29:
 660              	.L73:
 344:./src/Main.c  **** 			{
 345:./src/Main.c  **** 				pCom = &CommList[*(nMatchCommand + iStr)];
 346:./src/Main.c  **** 				break;
 347:./src/Main.c  **** 			}
 348:./src/Main.c  **** 			else pCom = &CommList[0];
 349:./src/Main.c  **** 			iStr++;
 661              		.loc 1 349 0 is_stmt 1
 662 007c 0133     		adds	r3, r3, #1
 663              	.LVL30:
 664 007e 9BB2     		uxth	r3, r3
 665              	.LVL31:
 666 0080 8419     		adds	r4, r0, r6
 340:./src/Main.c  **** 		while(iStr < nMatches)
 667              		.loc 1 340 0
 668 0082 4345     		cmp	r3, r8
 669 0084 2C44     		add	r4, r4, r5
 670 0086 00F11D00 		add	r0, r0, #29
 671 008a F3D1     		bne	.L75
 672              	.LVL32:
 673              	.L69:
 350:./src/Main.c  **** 		}
 351:./src/Main.c  **** 	}
 352:./src/Main.c  **** 	else pCom = &CommList[0];
 674              		.loc 1 352 0
 675 008c 0A4B     		ldr	r3, .L82
 353:./src/Main.c  **** 
 354:./src/Main.c  **** 	return nMatches;
 355:./src/Main.c  **** }
 676              		.loc 1 355 0
 677 008e 4046     		mov	r0, r8
 352:./src/Main.c  **** 	else pCom = &CommList[0];
 678              		.loc 1 352 0
 679 0090 C3F800C0 		str	ip, [r3]
 680              		.loc 1 355 0
 681 0094 BDE8F003 		pop	{r4, r5, r6, r7, r8, r9}
 682 0098 7047     		bx	lr
 683              	.LVL33:
 684              	.L81:
 685 009a 5B00     		lsls	r3, r3, #1
 686              	.LVL34:
 687              	.L70:
 345:./src/Main.c  **** 				pCom = &CommList[*(nMatchCommand + iStr)];
 688              		.loc 1 345 0
 689 009c D35A     		ldrh	r3, [r2, r3]
 690 009e 064A     		ldr	r2, .L82
 691              	.LVL35:
 692 00a0 C3EBC301 		rsb	r1, r3, r3, lsl #3
 693 00a4 03EB8103 		add	r3, r3, r1, lsl #2
 694 00a8 6344     		add	r3, r3, ip
 695              		.loc 1 355 0
 696 00aa 4046     		mov	r0, r8
 345:./src/Main.c  **** 				pCom = &CommList[*(nMatchCommand + iStr)];
 697              		.loc 1 345 0
 698 00ac 1360     		str	r3, [r2]
 699              		.loc 1 355 0
 700 00ae BDE8F003 		pop	{r4, r5, r6, r7, r8, r9}
 701 00b2 7047     		bx	lr
 702              	.LVL36:
 703              	.L80:
 343:./src/Main.c  **** 			if ((nChCom + 1) == (uint16_t) CommList[*nMatchCommand + iStr].length)
 704              		.loc 1 343 0
 705 00b4 0023     		movs	r3, #0
 706 00b6 F1E7     		b	.L70
 707              	.L83:
 708              		.align	2
 709              	.L82:
 710 00b8 00000000 		.word	.LANCHOR3
 711 00bc 00000000 		.word	.LANCHOR4
 712              		.cfi_endproc
 713              	.LFE61:
 715              		.section	.text.Poll,"ax",%progbits
 716              		.align	2
 717              		.global	Poll
 718              		.thumb
 719              		.thumb_func
 721              	Poll:
 722              	.LFB62:
 356:./src/Main.c  **** 
 357:./src/Main.c  **** 
 358:./src/Main.c  **** void
 359:./src/Main.c  **** Poll ()
 360:./src/Main.c  **** {
 723              		.loc 1 360 0
 724              		.cfi_startproc
 725              		@ args = 0, pretend = 0, frame = 104
 726              		@ frame_needed = 0, uses_anonymous_args = 0
 727              	.LVL37:
 728 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 729              		.cfi_def_cfa_offset 20
 730              		.cfi_offset 4, -20
 731              		.cfi_offset 5, -16
 732              		.cfi_offset 6, -12
 733              		.cfi_offset 7, -8
 734              		.cfi_offset 14, -4
 361:./src/Main.c  **** 	int i=0;
 362:./src/Main.c  **** 	static char value[N];
 363:./src/Main.c  **** 	/* Статичность обязательна, так как содержит номер начального символа команды и аргумента в pBuf*/
 364:./src/Main.c  **** 	static uint16_t nSymArg = 0;
 365:./src/Main.c  **** 	volatile char *pBuf;  //pointer to UART buffer
 366:./src/Main.c  **** 	static uint16_t nMatches = 0; //amount of matches
 367:./src/Main.c  **** 	uint16_t nMatchCommand[N];	//num of match
 368:./src/Main.c  **** 
 369:./src/Main.c  **** 	pBuf = Buf;
 370:./src/Main.c  **** 	switch(myStat)
 735              		.loc 1 370 0
 736 0002 854D     		ldr	r5, .L119
 360:./src/Main.c  **** {
 737              		.loc 1 360 0
 738 0004 9BB0     		sub	sp, sp, #108
 739              		.cfi_def_cfa_offset 128
 740              		.loc 1 370 0
 741 0006 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 742 0008 062B     		cmp	r3, #6
 743 000a 00F29680 		bhi	.L85
 744 000e DFE803F0 		tbb	[pc, r3]
 745              	.L87:
 746 0012 2C       		.byte	(.L84-.L87)/2
 747 0013 49       		.byte	(.L88-.L87)/2
 748 0014 64       		.byte	(.L89-.L87)/2
 749 0015 7B       		.byte	(.L90-.L87)/2
 750 0016 04       		.byte	(.L91-.L87)/2
 751 0017 69       		.byte	(.L92-.L87)/2
 752 0018 2E       		.byte	(.L93-.L87)/2
 753 0019 00       		.align	1
 754              	.L91:
 371:./src/Main.c  **** 	{
 372:./src/Main.c  **** 		case doNothing:
 373:./src/Main.c  **** 
 374:./src/Main.c  **** 			break;
 375:./src/Main.c  **** 		case clearing:
 376:./src/Main.c  **** 			pCom = &CommList[0];
 377:./src/Main.c  **** 			i = 1;
 378:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 379:./src/Main.c  **** 			{
 380:./src/Main.c  **** 				CommList[i].flag = 0;
 381:./src/Main.c  **** 				nMatchCommand[i] = 0;
 382:./src/Main.c  **** 				value[i] = '\0';
 383:./src/Main.c  **** 				i++;
 384:./src/Main.c  **** 			}
 385:./src/Main.c  **** 			n = 0;
 386:./src/Main.c  **** 			mainPointer = 0;
 387:./src/Main.c  **** 			byte.allFlags = 0;
 388:./src/Main.c  **** 			value[0] = '\0';
 389:./src/Main.c  **** 			myStat = doNothing;
 390:./src/Main.c  **** 			break;
 391:./src/Main.c  **** 		case checkingAddress:
 392:./src/Main.c  **** 				addrCheck(pBuf);
 393:./src/Main.c  **** 
 394:./src/Main.c  **** 			break;
 395:./src/Main.c  **** 		case iniSecondsS:
 396:./src/Main.c  **** 			mainPointer = 3;
 397:./src/Main.c  **** 			i = 1;
 398:./src/Main.c  **** 			pCom = &CommList[0];
 399:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 400:./src/Main.c  **** 			{
 401:./src/Main.c  **** 					CommList[i].flag = 0;
 402:./src/Main.c  **** 					nMatchCommand[i] = 0;
 403:./src/Main.c  **** 					value[i] = '\0';
 404:./src/Main.c  **** 					i++;
 405:./src/Main.c  **** 			}
 406:./src/Main.c  **** 
 407:./src/Main.c  **** 			value[0] = '\0';
 408:./src/Main.c  **** 			myStat = checkingCommand;
 409:./src/Main.c  **** 			break;
 410:./src/Main.c  **** 		case checkingCommand:
 411:./src/Main.c  **** 
 412:./src/Main.c  **** 			/* Checking if Pointer less then current number of symbols. */
 413:./src/Main.c  **** 			if (mainPointer <= n && n >= 3)
 755              		.loc 1 413 0
 756 001a 804B     		ldr	r3, .L119+4
 757 001c 804C     		ldr	r4, .L119+8
 758 001e 1A88     		ldrh	r2, [r3]
 759 0020 2688     		ldrh	r6, [r4]
 760 0022 92B2     		uxth	r2, r2
 761 0024 9642     		cmp	r6, r2
 762 0026 20D8     		bhi	.L84
 763              		.loc 1 413 0 is_stmt 0 discriminator 1
 764 0028 1B88     		ldrh	r3, [r3]
 765 002a 9BB2     		uxth	r3, r3
 766 002c 022B     		cmp	r3, #2
 767 002e 1CD9     		bls	.L84
 414:./src/Main.c  **** 			{
 415:./src/Main.c  **** 				/* Allow only alphabetical symbols. */
 416:./src/Main.c  **** 				if (!(*(pBuf + mainPointer - 1) >= '0' && *(pBuf + mainPointer - 1) <= '9') && *(pBuf + mainPoi
 768              		.loc 1 416 0 is_stmt 1
 769 0030 7C4B     		ldr	r3, .L119+12
 770 0032 701E     		subs	r0, r6, #1
 771 0034 1A5C     		ldrb	r2, [r3, r0]	@ zero_extendqisi2
 772 0036 1946     		mov	r1, r3
 773 0038 2F2A     		cmp	r2, #47
 774 003a 40F28B80 		bls	.L98
 775              		.loc 1 416 0 is_stmt 0 discriminator 2
 776 003e 1A5C     		ldrb	r2, [r3, r0]	@ zero_extendqisi2
 777 0040 392A     		cmp	r2, #57
 778 0042 00F28780 		bhi	.L98
 779              	.L99:
 417:./src/Main.c  **** 				{
 418:./src/Main.c  **** 					/* Bias to next symbol of command. */
 419:./src/Main.c  **** 					pBuf = &Buf[mainPointer - 1];
 420:./src/Main.c  **** 
 421:./src/Main.c  **** 					/* Отправляем буфер с первого символа команды, номер символа в команде,
 422:./src/Main.c  **** 					 * номер команды которая совпала.
 423:./src/Main.c  **** 					 * Получаем количество совпавших команд. */
 424:./src/Main.c  **** 					nMatches = Parse(pBuf, (mainPointer - 3), &nMatchCommand[0]);
 425:./src/Main.c  **** 
 426:./src/Main.c  **** 
 427:./src/Main.c  **** 					/* "Защита от второго начала команды s01".
 428:./src/Main.c  **** 					 * Из-за нее пришлось перестроить*/
 429:./src/Main.c  **** 					if (pCom->argFlag == 0x04)
 430:./src/Main.c  **** 						{
 431:./src/Main.c  **** 							myStat = checkingArgument;
 432:./src/Main.c  **** 							value[0] = '\0';
 433:./src/Main.c  **** 							pbit->comDone = true;
 434:./src/Main.c  **** 						}
 435:./src/Main.c  **** 					/* Защита от второго начала команды s01. */
 436:./src/Main.c  **** 
 437:./src/Main.c  **** 
 438:./src/Main.c  **** 					/* Смещение на 1 символ. */
 439:./src/Main.c  **** 					mainPointer++;
 440:./src/Main.c  **** 				}
 441:./src/Main.c  **** 				else
 442:./src/Main.c  **** 				{
 443:./src/Main.c  **** 					if (nMatches == 0)
 780              		.loc 1 443 0 is_stmt 1
 781 0046 784B     		ldr	r3, .L119+16
 782 0048 1F88     		ldrh	r7, [r3]
 783 004a 002F     		cmp	r7, #0
 784 004c 00F0CF80 		beq	.L117
 444:./src/Main.c  **** 						{
 445:./src/Main.c  **** 							_db_msg(LPC_UART0, "\r\nNot found matches\r\n");
 446:./src/Main.c  **** 							myStat = doNothing;
 447:./src/Main.c  **** 						}
 448:./src/Main.c  **** 					//	myStat = clearing;
 449:./src/Main.c  **** 					else
 450:./src/Main.c  **** 					{
 451:./src/Main.c  **** 						value[0] = '\0';
 452:./src/Main.c  **** 						pbit->comDone = true;
 785              		.loc 1 452 0
 786 0050 764B     		ldr	r3, .L119+20
 451:./src/Main.c  **** 						value[0] = '\0';
 787              		.loc 1 451 0
 788 0052 774A     		ldr	r2, .L119+24
 789              		.loc 1 452 0
 790 0054 1B68     		ldr	r3, [r3]
 451:./src/Main.c  **** 						value[0] = '\0';
 791              		.loc 1 451 0
 792 0056 0021     		movs	r1, #0
 793 0058 1170     		strb	r1, [r2]
 794              		.loc 1 452 0
 795 005a 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 453:./src/Main.c  **** 						myStat = checkingArgument;
 796              		.loc 1 453 0
 797 005c 0522     		movs	r2, #5
 452:./src/Main.c  **** 						pbit->comDone = true;
 798              		.loc 1 452 0
 799 005e 41F00401 		orr	r1, r1, #4
 800 0062 1970     		strb	r1, [r3]
 801              		.loc 1 453 0
 802 0064 2A70     		strb	r2, [r5]
 803              	.LVL38:
 804              	.L101:
 454:./src/Main.c  **** 					}
 455:./src/Main.c  **** 				}
 456:./src/Main.c  **** 				nSymArg = mainPointer;
 805              		.loc 1 456 0
 806 0066 734B     		ldr	r3, .L119+28
 807 0068 1E80     		strh	r6, [r3]	@ movhi
 808              	.L84:
 457:./src/Main.c  **** 			}
 458:./src/Main.c  **** 			break;
 459:./src/Main.c  **** 		case checkingArgument:
 460:./src/Main.c  **** 
 461:./src/Main.c  **** 			switch (pCom->argFlag)
 462:./src/Main.c  **** 			{
 463:./src/Main.c  **** 				case 1:
 464:./src/Main.c  **** 					pbit->allEnd = true;
 465:./src/Main.c  **** 					myStat = executing;
 466:./src/Main.c  **** 					break;
 467:./src/Main.c  **** 				case 2:
 468:./src/Main.c  **** 					if (mainPointer <= n)
 469:./src/Main.c  **** 					{
 470:./src/Main.c  **** 						if ( ( *(pBuf + mainPointer - 1) >= '0' &&*(pBuf + mainPointer - 1) <= '9') ||
 471:./src/Main.c  **** 								 *(pBuf + mainPointer - 1) =='-')
 472:./src/Main.c  **** 						{
 473:./src/Main.c  **** 							value[(mainPointer - nSymArg)] = *(pBuf + mainPointer - 1);
 474:./src/Main.c  **** 						//	_db_msg(LPC_UART0, "\r\nIn argument");
 475:./src/Main.c  **** 						}
 476:./src/Main.c  **** 						else
 477:./src/Main.c  **** 						{
 478:./src/Main.c  **** 							Errors();
 479:./src/Main.c  **** 							myStat = clearing;
 480:./src/Main.c  **** 						}
 481:./src/Main.c  **** 						mainPointer++;
 482:./src/Main.c  **** 					}
 483:./src/Main.c  **** 
 484:./src/Main.c  **** 					break;
 485:./src/Main.c  **** 				case 4:
 486:./src/Main.c  **** 					if (mainPointer <= n)
 487:./src/Main.c  **** 					{
 488:./src/Main.c  **** 						value[(mainPointer - nSymArg)] = *(pBuf + mainPointer - 1);
 489:./src/Main.c  **** 						mainPointer++;
 490:./src/Main.c  **** 					}
 491:./src/Main.c  **** 					break;
 492:./src/Main.c  **** 				default:
 493:./src/Main.c  **** 					break;
 494:./src/Main.c  **** 			}
 495:./src/Main.c  **** 			break;
 496:./src/Main.c  **** 		case executing:
 497:./src/Main.c  **** 
 498:./src/Main.c  **** 			if (pCom->length != 0)
 499:./src/Main.c  **** 			{
 500:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nething is good - ");
 501:./src/Main.c  **** 				_db_msg(LPC_UART0,pCom->name);
 502:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nvalue - ");
 503:./src/Main.c  **** 				_db_msg(LPC_UART0, value);
 504:./src/Main.c  **** 			}
 505:./src/Main.c  **** 			else Errors();
 506:./src/Main.c  **** 			myStat = clearing;
 507:./src/Main.c  **** 			break;
 508:./src/Main.c  **** 		default:
 509:./src/Main.c  **** 			_db_msg(LPC_UART0, "\r\nsmthWrong\r\n");
 510:./src/Main.c  **** 			break;
 511:./src/Main.c  **** 	}
 512:./src/Main.c  **** }
 809              		.loc 1 512 0
 810 006a 1BB0     		add	sp, sp, #108
 811              		@ sp needed
 812 006c F0BD     		pop	{r4, r5, r6, r7, pc}
 813              	.LVL39:
 814              	.L93:
 498:./src/Main.c  **** 			if (pCom->length != 0)
 815              		.loc 1 498 0
 816 006e 724E     		ldr	r6, .L119+32
 817 0070 3368     		ldr	r3, [r6]
 818 0072 DB7E     		ldrb	r3, [r3, #27]	@ zero_extendqisi2
 819 0074 002B     		cmp	r3, #0
 820 0076 67D0     		beq	.L110
 500:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nething is good - ");
 821              		.loc 1 500 0
 822 0078 704C     		ldr	r4, .L119+36
 823 007a 7148     		ldr	r0, .L119+40
 824 007c 2368     		ldr	r3, [r4]
 825 007e 7149     		ldr	r1, .L119+44
 826 0080 9847     		blx	r3
 827              	.LVL40:
 501:./src/Main.c  **** 				_db_msg(LPC_UART0,pCom->name);
 828              		.loc 1 501 0
 829 0082 3168     		ldr	r1, [r6]
 830 0084 2368     		ldr	r3, [r4]
 831 0086 0231     		adds	r1, r1, #2
 832 0088 6D48     		ldr	r0, .L119+40
 833 008a 9847     		blx	r3
 834              	.LVL41:
 502:./src/Main.c  **** 				_db_msg(LPC_UART0, "\r\nvalue - ");
 835              		.loc 1 502 0
 836 008c 2368     		ldr	r3, [r4]
 837 008e 6C48     		ldr	r0, .L119+40
 838 0090 6D49     		ldr	r1, .L119+48
 839 0092 9847     		blx	r3
 840              	.LVL42:
 503:./src/Main.c  **** 				_db_msg(LPC_UART0, value);
 841              		.loc 1 503 0
 842 0094 2368     		ldr	r3, [r4]
 843 0096 6A48     		ldr	r0, .L119+40
 844 0098 6549     		ldr	r1, .L119+24
 845 009a 9847     		blx	r3
 846              	.LVL43:
 847              	.L111:
 506:./src/Main.c  **** 			myStat = clearing;
 848              		.loc 1 506 0
 849 009c 0123     		movs	r3, #1
 850 009e 2B70     		strb	r3, [r5]
 851              		.loc 1 512 0
 852 00a0 1BB0     		add	sp, sp, #108
 853              		@ sp needed
 854 00a2 F0BD     		pop	{r4, r5, r6, r7, pc}
 855              	.L88:
 376:./src/Main.c  **** 			pCom = &CommList[0];
 856              		.loc 1 376 0
 857 00a4 694A     		ldr	r2, .L119+52
 858 00a6 6449     		ldr	r1, .L119+32
 859 00a8 614E     		ldr	r6, .L119+24
 860 00aa 0A60     		str	r2, [r1]
 861              	.LVL44:
 862 00ac 1346     		mov	r3, r2
 863 00ae 02F28D54 		addw	r4, r2, #1421
 864 00b2 3146     		mov	r1, r6
 380:./src/Main.c  **** 				CommList[i].flag = 0;
 865              		.loc 1 380 0
 866 00b4 0022     		movs	r2, #0
 867              	.LVL45:
 868              	.L95:
 869 00b6 9A77     		strb	r2, [r3, #30]
 870 00b8 1D33     		adds	r3, r3, #29
 378:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 871              		.loc 1 378 0
 872 00ba A342     		cmp	r3, r4
 382:./src/Main.c  **** 				value[i] = '\0';
 873              		.loc 1 382 0
 874 00bc 01F8012F 		strb	r2, [r1, #1]!
 875              	.LVL46:
 380:./src/Main.c  **** 				CommList[i].flag = 0;
 876              		.loc 1 380 0
 877 00c0 4FF00000 		mov	r0, #0
 378:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 878              		.loc 1 378 0
 879 00c4 F7D1     		bne	.L95
 385:./src/Main.c  **** 			n = 0;
 880              		.loc 1 385 0
 881 00c6 5549     		ldr	r1, .L119+4
 882              	.LVL47:
 387:./src/Main.c  **** 			byte.allFlags = 0;
 883              		.loc 1 387 0
 884 00c8 614B     		ldr	r3, .L119+56
 386:./src/Main.c  **** 			mainPointer = 0;
 885              		.loc 1 386 0
 886 00ca 554A     		ldr	r2, .L119+8
 385:./src/Main.c  **** 			n = 0;
 887              		.loc 1 385 0
 888 00cc 0880     		strh	r0, [r1]	@ movhi
 388:./src/Main.c  **** 			value[0] = '\0';
 889              		.loc 1 388 0
 890 00ce 3070     		strb	r0, [r6]
 387:./src/Main.c  **** 			byte.allFlags = 0;
 891              		.loc 1 387 0
 892 00d0 1870     		strb	r0, [r3]
 386:./src/Main.c  **** 			mainPointer = 0;
 893              		.loc 1 386 0
 894 00d2 1080     		strh	r0, [r2]	@ movhi
 389:./src/Main.c  **** 			myStat = doNothing;
 895              		.loc 1 389 0
 896 00d4 2870     		strb	r0, [r5]
 897              		.loc 1 512 0
 898 00d6 1BB0     		add	sp, sp, #108
 899              		@ sp needed
 900 00d8 F0BD     		pop	{r4, r5, r6, r7, pc}
 901              	.LVL48:
 902              	.L89:
 392:./src/Main.c  **** 				addrCheck(pBuf);
 903              		.loc 1 392 0
 904 00da 5248     		ldr	r0, .L119+12
 905 00dc FFF7FEFF 		bl	addrCheck
 906              	.LVL49:
 907              		.loc 1 512 0
 908 00e0 1BB0     		add	sp, sp, #108
 909              		@ sp needed
 910 00e2 F0BD     		pop	{r4, r5, r6, r7, pc}
 911              	.L92:
 461:./src/Main.c  **** 			switch (pCom->argFlag)
 912              		.loc 1 461 0
 913 00e4 544B     		ldr	r3, .L119+32
 914 00e6 1B68     		ldr	r3, [r3]
 915 00e8 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 916 00ea 022B     		cmp	r3, #2
 917 00ec 5AD0     		beq	.L103
 918 00ee 042B     		cmp	r3, #4
 919 00f0 45D0     		beq	.L104
 920 00f2 012B     		cmp	r3, #1
 921 00f4 B9D1     		bne	.L84
 464:./src/Main.c  **** 					pbit->allEnd = true;
 922              		.loc 1 464 0
 923 00f6 4D4B     		ldr	r3, .L119+20
 465:./src/Main.c  **** 					myStat = executing;
 924              		.loc 1 465 0
 925 00f8 0622     		movs	r2, #6
 464:./src/Main.c  **** 					pbit->allEnd = true;
 926              		.loc 1 464 0
 927 00fa 1B68     		ldr	r3, [r3]
 928 00fc 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 929 00fe 41F00801 		orr	r1, r1, #8
 930 0102 1970     		strb	r1, [r3]
 465:./src/Main.c  **** 					myStat = executing;
 931              		.loc 1 465 0
 932 0104 2A70     		strb	r2, [r5]
 466:./src/Main.c  **** 					break;
 933              		.loc 1 466 0
 934 0106 B0E7     		b	.L84
 935              	.L90:
 398:./src/Main.c  **** 			pCom = &CommList[0];
 936              		.loc 1 398 0
 937 0108 504A     		ldr	r2, .L119+52
 938 010a 4B4C     		ldr	r4, .L119+32
 396:./src/Main.c  **** 			mainPointer = 3;
 939              		.loc 1 396 0
 940 010c 4449     		ldr	r1, .L119+8
 941 010e 484E     		ldr	r6, .L119+24
 942 0110 0320     		movs	r0, #3
 398:./src/Main.c  **** 			pCom = &CommList[0];
 943              		.loc 1 398 0
 944 0112 2260     		str	r2, [r4]
 945 0114 1346     		mov	r3, r2
 946 0116 02F28D54 		addw	r4, r2, #1421
 396:./src/Main.c  **** 			mainPointer = 3;
 947              		.loc 1 396 0
 948 011a 0880     		strh	r0, [r1]	@ movhi
 949              	.LVL50:
 401:./src/Main.c  **** 					CommList[i].flag = 0;
 950              		.loc 1 401 0
 951 011c 0022     		movs	r2, #0
 952 011e 3146     		mov	r1, r6
 953              	.LVL51:
 954              	.L97:
 955 0120 9A77     		strb	r2, [r3, #30]
 956 0122 1D33     		adds	r3, r3, #29
 399:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 957              		.loc 1 399 0
 958 0124 A342     		cmp	r3, r4
 403:./src/Main.c  **** 					value[i] = '\0';
 959              		.loc 1 403 0
 960 0126 01F8012F 		strb	r2, [r1, #1]!
 961              	.LVL52:
 401:./src/Main.c  **** 					CommList[i].flag = 0;
 962              		.loc 1 401 0
 963 012a 4FF00000 		mov	r0, #0
 399:./src/Main.c  **** 			while(i < N)  //brute force all commands by 1 character
 964              		.loc 1 399 0
 965 012e F7D1     		bne	.L97
 408:./src/Main.c  **** 			myStat = checkingCommand;
 966              		.loc 1 408 0
 967 0130 0423     		movs	r3, #4
 407:./src/Main.c  **** 			value[0] = '\0';
 968              		.loc 1 407 0
 969 0132 3070     		strb	r0, [r6]
 408:./src/Main.c  **** 			myStat = checkingCommand;
 970              		.loc 1 408 0
 971 0134 2B70     		strb	r3, [r5]
 972              		.loc 1 512 0
 973 0136 1BB0     		add	sp, sp, #108
 974              		@ sp needed
 975 0138 F0BD     		pop	{r4, r5, r6, r7, pc}
 976              	.LVL53:
 977              	.L85:
 509:./src/Main.c  **** 			_db_msg(LPC_UART0, "\r\nsmthWrong\r\n");
 978              		.loc 1 509 0
 979 013a 404B     		ldr	r3, .L119+36
 980 013c 4048     		ldr	r0, .L119+40
 981 013e 1B68     		ldr	r3, [r3]
 982 0140 4449     		ldr	r1, .L119+60
 983 0142 9847     		blx	r3
 984              	.LVL54:
 985              		.loc 1 512 0
 986 0144 1BB0     		add	sp, sp, #108
 987              		@ sp needed
 988 0146 F0BD     		pop	{r4, r5, r6, r7, pc}
 989              	.L110:
 990              	.LBB8:
 991              	.LBB9:
 313:./src/Main.c  **** 	_db_msg(LPC_UART0, "\r\nError \r\n");
 992              		.loc 1 313 0
 993 0148 3C4B     		ldr	r3, .L119+36
 994 014a 3D48     		ldr	r0, .L119+40
 995 014c 1B68     		ldr	r3, [r3]
 996 014e 4249     		ldr	r1, .L119+64
 997 0150 9847     		blx	r3
 998              	.LVL55:
 999 0152 A3E7     		b	.L111
 1000              	.L98:
 1001              	.LBE9:
 1002              	.LBE8:
 416:./src/Main.c  **** 				if (!(*(pBuf + mainPointer - 1) >= '0' && *(pBuf + mainPointer - 1) <= '9') && *(pBuf + mainPoi
 1003              		.loc 1 416 0 discriminator 1
 1004 0154 0A5C     		ldrb	r2, [r1, r0]	@ zero_extendqisi2
 1005 0156 2D2A     		cmp	r2, #45
 1006 0158 3FF475AF 		beq	.L99
 1007              	.LVL56:
 424:./src/Main.c  **** 					nMatches = Parse(pBuf, (mainPointer - 3), &nMatchCommand[0]);
 1008              		.loc 1 424 0
 1009 015c F11E     		subs	r1, r6, #3
 1010 015e 1844     		add	r0, r0, r3
 1011 0160 01AA     		add	r2, sp, #4
 1012 0162 89B2     		uxth	r1, r1
 1013 0164 FFF7FEFF 		bl	Parse
 1014              	.LVL57:
 429:./src/Main.c  **** 					if (pCom->argFlag == 0x04)
 1015              		.loc 1 429 0
 1016 0168 334B     		ldr	r3, .L119+32
 424:./src/Main.c  **** 					nMatches = Parse(pBuf, (mainPointer - 3), &nMatchCommand[0]);
 1017              		.loc 1 424 0
 1018 016a 2F4A     		ldr	r2, .L119+16
 429:./src/Main.c  **** 					if (pCom->argFlag == 0x04)
 1019              		.loc 1 429 0
 1020 016c 1B68     		ldr	r3, [r3]
 424:./src/Main.c  **** 					nMatches = Parse(pBuf, (mainPointer - 3), &nMatchCommand[0]);
 1021              		.loc 1 424 0
 1022 016e 1080     		strh	r0, [r2]	@ movhi
 429:./src/Main.c  **** 					if (pCom->argFlag == 0x04)
 1023              		.loc 1 429 0
 1024 0170 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 1025 0172 042B     		cmp	r3, #4
 1026 0174 43D0     		beq	.L118
 1027              	.L100:
 439:./src/Main.c  **** 					mainPointer++;
 1028              		.loc 1 439 0
 1029 0176 0136     		adds	r6, r6, #1
 1030              	.LVL58:
 1031 0178 B6B2     		uxth	r6, r6
 1032              	.LVL59:
 1033 017a 2680     		strh	r6, [r4]	@ movhi
 1034 017c 73E7     		b	.L101
 1035              	.LVL60:
 1036              	.L104:
 486:./src/Main.c  **** 					if (mainPointer <= n)
 1037              		.loc 1 486 0
 1038 017e 274B     		ldr	r3, .L119+4
 1039 0180 274A     		ldr	r2, .L119+8
 1040 0182 1988     		ldrh	r1, [r3]
 1041 0184 1388     		ldrh	r3, [r2]
 1042 0186 89B2     		uxth	r1, r1
 1043 0188 8B42     		cmp	r3, r1
 1044 018a 3FF66EAF 		bhi	.L84
 488:./src/Main.c  **** 						value[(mainPointer - nSymArg)] = *(pBuf + mainPointer - 1);
 1045              		.loc 1 488 0
 1046 018e 2949     		ldr	r1, .L119+28
 1047 0190 2448     		ldr	r0, .L119+12
 1048 0192 5C1E     		subs	r4, r3, #1
 1049 0194 0988     		ldrh	r1, [r1]
 1050 0196 245C     		ldrb	r4, [r4, r0]	@ zero_extendqisi2
 1051 0198 2548     		ldr	r0, .L119+24
 1052 019a 591A     		subs	r1, r3, r1
 489:./src/Main.c  **** 						mainPointer++;
 1053              		.loc 1 489 0
 1054 019c 0133     		adds	r3, r3, #1
 1055 019e 1380     		strh	r3, [r2]	@ movhi
 488:./src/Main.c  **** 						value[(mainPointer - nSymArg)] = *(pBuf + mainPointer - 1);
 1056              		.loc 1 488 0
 1057 01a0 4454     		strb	r4, [r0, r1]
 1058 01a2 62E7     		b	.L84
 1059              	.L103:
 468:./src/Main.c  **** 					if (mainPointer <= n)
 1060              		.loc 1 468 0
 1061 01a4 1D4B     		ldr	r3, .L119+4
 1062 01a6 1E4C     		ldr	r4, .L119+8
 1063 01a8 1A88     		ldrh	r2, [r3]
 1064 01aa 2388     		ldrh	r3, [r4]
 1065 01ac 92B2     		uxth	r2, r2
 1066 01ae 9342     		cmp	r3, r2
 1067 01b0 3FF65BAF 		bhi	.L84
 470:./src/Main.c  **** 						if ( ( *(pBuf + mainPointer - 1) >= '0' &&*(pBuf + mainPointer - 1) <= '9') ||
 1068              		.loc 1 470 0
 1069 01b4 1B4A     		ldr	r2, .L119+12
 1070 01b6 591E     		subs	r1, r3, #1
 1071 01b8 885C     		ldrb	r0, [r1, r2]	@ zero_extendqisi2
 1072 01ba 2F28     		cmp	r0, #47
 1073 01bc 0BD9     		bls	.L106
 470:./src/Main.c  **** 						if ( ( *(pBuf + mainPointer - 1) >= '0' &&*(pBuf + mainPointer - 1) <= '9') ||
 1074              		.loc 1 470 0 is_stmt 0 discriminator 1
 1075 01be 885C     		ldrb	r0, [r1, r2]	@ zero_extendqisi2
 1076 01c0 3928     		cmp	r0, #57
 1077 01c2 08D8     		bhi	.L106
 1078              	.L107:
 473:./src/Main.c  **** 							value[(mainPointer - nSymArg)] = *(pBuf + mainPointer - 1);
 1079              		.loc 1 473 0 is_stmt 1
 1080 01c4 1B4D     		ldr	r5, .L119+28
 1081 01c6 885C     		ldrb	r0, [r1, r2]	@ zero_extendqisi2
 1082 01c8 2A88     		ldrh	r2, [r5]
 1083 01ca 1949     		ldr	r1, .L119+24
 1084 01cc 9A1A     		subs	r2, r3, r2
 1085 01ce 8854     		strb	r0, [r1, r2]
 1086              	.L109:
 481:./src/Main.c  **** 						mainPointer++;
 1087              		.loc 1 481 0
 1088 01d0 0133     		adds	r3, r3, #1
 1089 01d2 2380     		strh	r3, [r4]	@ movhi
 1090 01d4 49E7     		b	.L84
 1091              	.L106:
 471:./src/Main.c  **** 								 *(pBuf + mainPointer - 1) =='-')
 1092              		.loc 1 471 0 discriminator 2
 1093 01d6 885C     		ldrb	r0, [r1, r2]	@ zero_extendqisi2
 470:./src/Main.c  **** 						if ( ( *(pBuf + mainPointer - 1) >= '0' &&*(pBuf + mainPointer - 1) <= '9') ||
 1094              		.loc 1 470 0 discriminator 2
 1095 01d8 2D28     		cmp	r0, #45
 1096 01da F3D0     		beq	.L107
 1097              	.LBB10:
 1098              	.LBB11:
 313:./src/Main.c  **** 	_db_msg(LPC_UART0, "\r\nError \r\n");
 1099              		.loc 1 313 0
 1100 01dc 174B     		ldr	r3, .L119+36
 1101 01de 1848     		ldr	r0, .L119+40
 1102 01e0 1B68     		ldr	r3, [r3]
 1103 01e2 1D49     		ldr	r1, .L119+64
 1104 01e4 9847     		blx	r3
 1105              	.LVL61:
 1106              	.LBE11:
 1107              	.LBE10:
 479:./src/Main.c  **** 							myStat = clearing;
 1108              		.loc 1 479 0
 1109 01e6 0122     		movs	r2, #1
 1110 01e8 2388     		ldrh	r3, [r4]
 1111 01ea 2A70     		strb	r2, [r5]
 1112 01ec F0E7     		b	.L109
 1113              	.L117:
 445:./src/Main.c  **** 							_db_msg(LPC_UART0, "\r\nNot found matches\r\n");
 1114              		.loc 1 445 0
 1115 01ee 134B     		ldr	r3, .L119+36
 1116 01f0 1348     		ldr	r0, .L119+40
 1117 01f2 1B68     		ldr	r3, [r3]
 1118 01f4 1949     		ldr	r1, .L119+68
 1119 01f6 9847     		blx	r3
 1120              	.LVL62:
 446:./src/Main.c  **** 							myStat = doNothing;
 1121              		.loc 1 446 0
 1122 01f8 2F70     		strb	r7, [r5]
 1123 01fa 2688     		ldrh	r6, [r4]
 1124 01fc 33E7     		b	.L101
 1125              	.LVL63:
 1126              	.L118:
 433:./src/Main.c  **** 							pbit->comDone = true;
 1127              		.loc 1 433 0
 1128 01fe 0B4B     		ldr	r3, .L119+20
 432:./src/Main.c  **** 							value[0] = '\0';
 1129              		.loc 1 432 0
 1130 0200 0B49     		ldr	r1, .L119+24
 433:./src/Main.c  **** 							pbit->comDone = true;
 1131              		.loc 1 433 0
 1132 0202 1B68     		ldr	r3, [r3]
 431:./src/Main.c  **** 							myStat = checkingArgument;
 1133              		.loc 1 431 0
 1134 0204 0522     		movs	r2, #5
 432:./src/Main.c  **** 							value[0] = '\0';
 1135              		.loc 1 432 0
 1136 0206 0020     		movs	r0, #0
 1137 0208 0870     		strb	r0, [r1]
 431:./src/Main.c  **** 							myStat = checkingArgument;
 1138              		.loc 1 431 0
 1139 020a 2A70     		strb	r2, [r5]
 433:./src/Main.c  **** 							pbit->comDone = true;
 1140              		.loc 1 433 0
 1141 020c 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1142 020e 42F00402 		orr	r2, r2, #4
 1143 0212 1A70     		strb	r2, [r3]
 1144 0214 AFE7     		b	.L100
 1145              	.L120:
 1146 0216 00BF     		.align	2
 1147              	.L119:
 1148 0218 00000000 		.word	myStat
 1149 021c 00000000 		.word	.LANCHOR0
 1150 0220 00000000 		.word	.LANCHOR2
 1151 0224 00000000 		.word	Buf
 1152 0228 00000000 		.word	.LANCHOR6
 1153 022c 00000000 		.word	.LANCHOR1
 1154 0230 00000000 		.word	.LANCHOR5
 1155 0234 00000000 		.word	.LANCHOR7
 1156 0238 00000000 		.word	.LANCHOR3
 1157 023c 00000000 		.word	_db_msg
 1158 0240 00C00040 		.word	1073790976
 1159 0244 B4000000 		.word	.LC9
 1160 0248 C8000000 		.word	.LC10
 1161 024c 00000000 		.word	.LANCHOR4
 1162 0250 00000000 		.word	byte
 1163 0254 D4000000 		.word	.LC11
 1164 0258 90000000 		.word	.LC7
 1165 025c 9C000000 		.word	.LC8
 1166              		.cfi_endproc
 1167              	.LFE62:
 1169              		.section	.text.startup.main,"ax",%progbits
 1170              		.align	2
 1171              		.global	main
 1172              		.thumb
 1173              		.thumb_func
 1175              	main:
 1176              	.LFB63:
 513:./src/Main.c  **** 
 514:./src/Main.c  **** 
 515:./src/Main.c  **** /*----------------------------------------------------------------------------
 516:./src/Main.c  ****  Main Program
 517:./src/Main.c  ****  *---------------------------------------------------------------------------*/
 518:./src/Main.c  **** 
 519:./src/Main.c  **** int main(void)
 520:./src/Main.c  **** {
 1177              		.loc 1 520 0
 1178              		.cfi_startproc
 1179              		@ args = 0, pretend = 0, frame = 0
 1180              		@ frame_needed = 0, uses_anonymous_args = 0
 1181 0000 10B5     		push	{r4, lr}
 1182              		.cfi_def_cfa_offset 8
 1183              		.cfi_offset 4, -8
 1184              		.cfi_offset 14, -4
 521:./src/Main.c  **** 
 522:./src/Main.c  **** 	debug_frmwrk_init(); //интерфейс отладки, дебаг интерфейс
 1185              		.loc 1 522 0
 1186 0002 FFF7FEFF 		bl	debug_frmwrk_init
 1187              	.LVL64:
 523:./src/Main.c  ****    _db_msg(LPC_UART0, "\r\nHello I'am SHIM  ver. 0.1\r\n");
 1188              		.loc 1 523 0
 1189 0006 164C     		ldr	r4, .L123
 1190 0008 164B     		ldr	r3, .L123+4
 1191 000a 2046     		mov	r0, r4
 1192 000c 1B68     		ldr	r3, [r3]
 1193 000e 1649     		ldr	r1, .L123+8
 1194 0010 9847     		blx	r3
 1195              	.LVL65:
 524:./src/Main.c  **** 
 525:./src/Main.c  **** 	LPC_UART0->LCR &= ~(1<<7);  //  DLAB =0
 1196              		.loc 1 525 0
 1197 0012 237B     		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 1198              	.LBB12:
 1199              	.LBB13:
 1200              		.file 2 "./Core/core_cm3.h"
   1:./Core/core_cm3.h **** /**************************************************************************//**
   2:./Core/core_cm3.h ****  * @file     core_cm3.h
   3:./Core/core_cm3.h ****  * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
   4:./Core/core_cm3.h ****  * @version  V2.01
   5:./Core/core_cm3.h ****  * @date     06. December 2010
   6:./Core/core_cm3.h ****  *
   7:./Core/core_cm3.h ****  * @note
   8:./Core/core_cm3.h ****  * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
   9:./Core/core_cm3.h ****  *
  10:./Core/core_cm3.h ****  * @par
  11:./Core/core_cm3.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M
  12:./Core/core_cm3.h ****  * processor based microcontrollers.  This file can be freely distributed
  13:./Core/core_cm3.h ****  * within development tools that are supporting such ARM based processors.
  14:./Core/core_cm3.h ****  *
  15:./Core/core_cm3.h ****  * @par
  16:./Core/core_cm3.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:./Core/core_cm3.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:./Core/core_cm3.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:./Core/core_cm3.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:./Core/core_cm3.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:./Core/core_cm3.h ****  *
  22:./Core/core_cm3.h ****  ******************************************************************************/
  23:./Core/core_cm3.h **** #if defined ( __ICCARM__ )
  24:./Core/core_cm3.h ****  #pragma system_include  /* treat file as system include file for MISRA check */
  25:./Core/core_cm3.h **** #endif
  26:./Core/core_cm3.h **** 
  27:./Core/core_cm3.h **** #ifdef __cplusplus
  28:./Core/core_cm3.h ****  extern "C" {
  29:./Core/core_cm3.h **** #endif
  30:./Core/core_cm3.h **** 
  31:./Core/core_cm3.h **** #ifndef __CORE_CM3_H_GENERIC
  32:./Core/core_cm3.h **** #define __CORE_CM3_H_GENERIC
  33:./Core/core_cm3.h **** 
  34:./Core/core_cm3.h **** /** @addtogroup CMSIS_core_LintCinfiguration CMSIS Core Lint Configuration
  35:./Core/core_cm3.h ****   List of Lint messages which will be suppressed and not shown:
  36:./Core/core_cm3.h ****     - not yet checked
  37:./Core/core_cm3.h ****   .
  38:./Core/core_cm3.h ****   Note:  To re-enable a Message, insert a space before 'lint' *
  39:./Core/core_cm3.h **** 
  40:./Core/core_cm3.h ****  */
  41:./Core/core_cm3.h **** 
  42:./Core/core_cm3.h **** 
  43:./Core/core_cm3.h **** /*******************************************************************************
  44:./Core/core_cm3.h ****  *                 CMSIS definitions
  45:./Core/core_cm3.h ****  ******************************************************************************/
  46:./Core/core_cm3.h **** /** @addtogroup CMSIS_core_definitions CMSIS Core Definitions
  47:./Core/core_cm3.h ****   This file defines all structures and symbols for CMSIS core:
  48:./Core/core_cm3.h ****    - CMSIS version number
  49:./Core/core_cm3.h ****    - Cortex-M core
  50:./Core/core_cm3.h ****    - Cortex-M core Revision Number
  51:./Core/core_cm3.h ****   @{
  52:./Core/core_cm3.h ****  */
  53:./Core/core_cm3.h **** 
  54:./Core/core_cm3.h **** /*  CMSIS CM3 definitions */
  55:./Core/core_cm3.h **** #define __CM3_CMSIS_VERSION_MAIN  (0x02)                                                       /*!<
  56:./Core/core_cm3.h **** #define __CM3_CMSIS_VERSION_SUB   (0x00)                                                       /*!<
  57:./Core/core_cm3.h **** #define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!<
  58:./Core/core_cm3.h **** 
  59:./Core/core_cm3.h **** #define __CORTEX_M                (0x03)                                                       /*!<
  60:./Core/core_cm3.h **** 
  61:./Core/core_cm3.h **** 
  62:./Core/core_cm3.h **** #if defined ( __CC_ARM   )
  63:./Core/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  64:./Core/core_cm3.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  65:./Core/core_cm3.h **** 
  66:./Core/core_cm3.h **** #elif defined ( __ICCARM__ )
  67:./Core/core_cm3.h ****   #define __ASM           __asm                                       /*!< asm keyword for IAR Comp
  68:./Core/core_cm3.h ****   #define __INLINE        inline                                      /*!< inline keyword for IAR C
  69:./Core/core_cm3.h **** 
  70:./Core/core_cm3.h **** #elif defined   (  __GNUC__  )
  71:./Core/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  72:./Core/core_cm3.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  73:./Core/core_cm3.h **** 
  74:./Core/core_cm3.h **** #elif defined   (  __TASKING__  )
  75:./Core/core_cm3.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
  76:./Core/core_cm3.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
  77:./Core/core_cm3.h **** 
  78:./Core/core_cm3.h **** #endif
  79:./Core/core_cm3.h **** 
  80:./Core/core_cm3.h **** #include <stdint.h>                      /*!< standard types definitions                      */
  81:./Core/core_cm3.h **** #include "core_cmInstr.h"                /*!< Core Instruction Access                         */
  82:./Core/core_cm3.h **** #include "core_cmFunc.h"                 /*!< Core Function Access                            */
  83:./Core/core_cm3.h **** 
  84:./Core/core_cm3.h **** #endif /* __CORE_CM3_H_GENERIC */
  85:./Core/core_cm3.h **** 
  86:./Core/core_cm3.h **** 
  87:./Core/core_cm3.h **** #ifndef __CMSIS_GENERIC
  88:./Core/core_cm3.h **** 
  89:./Core/core_cm3.h **** #ifndef __CORE_CM3_H_DEPENDANT
  90:./Core/core_cm3.h **** #define __CORE_CM3_H_DEPENDANT
  91:./Core/core_cm3.h **** 
  92:./Core/core_cm3.h **** /* IO definitions (access restrictions to peripheral registers) */
  93:./Core/core_cm3.h **** #ifdef __cplusplus
  94:./Core/core_cm3.h ****   #define     __I     volatile           /*!< defines 'read only' permissions                 */
  95:./Core/core_cm3.h **** #else
  96:./Core/core_cm3.h ****   #define     __I     volatile const     /*!< defines 'read only' permissions                 */
  97:./Core/core_cm3.h **** #endif
  98:./Core/core_cm3.h **** #define     __O     volatile             /*!< defines 'write only' permissions                */
  99:./Core/core_cm3.h **** #define     __IO    volatile             /*!< defines 'read / write' permissions              */
 100:./Core/core_cm3.h **** 
 101:./Core/core_cm3.h **** /*@} end of group CMSIS_core_definitions */
 102:./Core/core_cm3.h **** 
 103:./Core/core_cm3.h **** 
 104:./Core/core_cm3.h **** 
 105:./Core/core_cm3.h **** /*******************************************************************************
 106:./Core/core_cm3.h ****  *                 Register Abstraction
 107:./Core/core_cm3.h ****  ******************************************************************************/
 108:./Core/core_cm3.h **** /** @addtogroup CMSIS_core_register CMSIS Core Register
 109:./Core/core_cm3.h ****   Core Register contain:
 110:./Core/core_cm3.h ****   - Core Register
 111:./Core/core_cm3.h ****   - Core NVIC Register
 112:./Core/core_cm3.h ****   - Core SCB Register
 113:./Core/core_cm3.h ****   - Core SysTick Register
 114:./Core/core_cm3.h ****   - Core Debug Register
 115:./Core/core_cm3.h ****   - Core MPU Register
 116:./Core/core_cm3.h **** */
 117:./Core/core_cm3.h **** 
 118:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 119:./Core/core_cm3.h ****     \defgroup CMSIS_CORE CMSIS Core
 120:./Core/core_cm3.h ****   Type definitions for the Cortex-M Core Registers
 121:./Core/core_cm3.h ****   @{
 122:./Core/core_cm3.h ****  */
 123:./Core/core_cm3.h **** 
 124:./Core/core_cm3.h **** /** \brief  Union type to access the Application Program Status Register (APSR).
 125:./Core/core_cm3.h ****  */
 126:./Core/core_cm3.h **** typedef union
 127:./Core/core_cm3.h **** {
 128:./Core/core_cm3.h ****   struct
 129:./Core/core_cm3.h ****   {
 130:./Core/core_cm3.h **** #if (__CORTEX_M != 0x04)
 131:./Core/core_cm3.h ****     uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
 132:./Core/core_cm3.h **** #else
 133:./Core/core_cm3.h ****     uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
 134:./Core/core_cm3.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 135:./Core/core_cm3.h ****     uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
 136:./Core/core_cm3.h **** #endif
 137:./Core/core_cm3.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
 138:./Core/core_cm3.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 139:./Core/core_cm3.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 140:./Core/core_cm3.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 141:./Core/core_cm3.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 142:./Core/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 143:./Core/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 144:./Core/core_cm3.h **** } APSR_Type;
 145:./Core/core_cm3.h **** 
 146:./Core/core_cm3.h **** 
 147:./Core/core_cm3.h **** /** \brief  Union type to access the Interrupt Program Status Register (IPSR).
 148:./Core/core_cm3.h ****  */
 149:./Core/core_cm3.h **** typedef union
 150:./Core/core_cm3.h **** {
 151:./Core/core_cm3.h ****   struct
 152:./Core/core_cm3.h ****   {
 153:./Core/core_cm3.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 154:./Core/core_cm3.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
 155:./Core/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 156:./Core/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 157:./Core/core_cm3.h **** } IPSR_Type;
 158:./Core/core_cm3.h **** 
 159:./Core/core_cm3.h **** 
 160:./Core/core_cm3.h **** /** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 161:./Core/core_cm3.h ****  */
 162:./Core/core_cm3.h **** typedef union
 163:./Core/core_cm3.h **** {
 164:./Core/core_cm3.h ****   struct
 165:./Core/core_cm3.h ****   {
 166:./Core/core_cm3.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
 167:./Core/core_cm3.h **** #if (__CORTEX_M != 0x04)
 168:./Core/core_cm3.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
 169:./Core/core_cm3.h **** #else
 170:./Core/core_cm3.h ****     uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
 171:./Core/core_cm3.h ****     uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
 172:./Core/core_cm3.h ****     uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
 173:./Core/core_cm3.h **** #endif
 174:./Core/core_cm3.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
 175:./Core/core_cm3.h ****     uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
 176:./Core/core_cm3.h ****     uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
 177:./Core/core_cm3.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
 178:./Core/core_cm3.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
 179:./Core/core_cm3.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
 180:./Core/core_cm3.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
 181:./Core/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 182:./Core/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 183:./Core/core_cm3.h **** } xPSR_Type;
 184:./Core/core_cm3.h **** 
 185:./Core/core_cm3.h **** 
 186:./Core/core_cm3.h **** /** \brief  Union type to access the Control Registers (CONTROL).
 187:./Core/core_cm3.h ****  */
 188:./Core/core_cm3.h **** typedef union
 189:./Core/core_cm3.h **** {
 190:./Core/core_cm3.h ****   struct
 191:./Core/core_cm3.h ****   {
 192:./Core/core_cm3.h ****     uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
 193:./Core/core_cm3.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
 194:./Core/core_cm3.h ****     uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
 195:./Core/core_cm3.h ****     uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
 196:./Core/core_cm3.h ****   } b;                                   /*!< Structure used for bit  access                  */
 197:./Core/core_cm3.h ****   uint32_t w;                            /*!< Type      used for word access                  */
 198:./Core/core_cm3.h **** } CONTROL_Type;
 199:./Core/core_cm3.h **** 
 200:./Core/core_cm3.h **** /*@} end of group CMSIS_CORE */
 201:./Core/core_cm3.h **** 
 202:./Core/core_cm3.h **** 
 203:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 204:./Core/core_cm3.h ****     \defgroup CMSIS_NVIC CMSIS NVIC
 205:./Core/core_cm3.h ****   Type definitions for the Cortex-M NVIC Registers
 206:./Core/core_cm3.h ****   @{
 207:./Core/core_cm3.h ****  */
 208:./Core/core_cm3.h **** 
 209:./Core/core_cm3.h **** /** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 210:./Core/core_cm3.h ****  */
 211:./Core/core_cm3.h **** typedef struct
 212:./Core/core_cm3.h **** {
 213:./Core/core_cm3.h ****   __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register   
 214:./Core/core_cm3.h ****        uint32_t RESERVED0[24];
 215:./Core/core_cm3.h ****   __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 216:./Core/core_cm3.h ****        uint32_t RSERVED1[24];
 217:./Core/core_cm3.h ****   __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register  
 218:./Core/core_cm3.h ****        uint32_t RESERVED2[24];
 219:./Core/core_cm3.h ****   __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 220:./Core/core_cm3.h ****        uint32_t RESERVED3[24];
 221:./Core/core_cm3.h ****   __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register   
 222:./Core/core_cm3.h ****        uint32_t RESERVED4[56];
 223:./Core/core_cm3.h ****   __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bi
 224:./Core/core_cm3.h ****        uint32_t RESERVED5[644];
 225:./Core/core_cm3.h ****   __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Regis
 226:./Core/core_cm3.h **** }  NVIC_Type;
 227:./Core/core_cm3.h **** 
 228:./Core/core_cm3.h **** /*@} end of group CMSIS_NVIC */
 229:./Core/core_cm3.h **** 
 230:./Core/core_cm3.h **** 
 231:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 232:./Core/core_cm3.h ****     \defgroup CMSIS_SCB CMSIS SCB
 233:./Core/core_cm3.h ****   Type definitions for the Cortex-M System Control Block Registers
 234:./Core/core_cm3.h ****   @{
 235:./Core/core_cm3.h ****  */
 236:./Core/core_cm3.h **** 
 237:./Core/core_cm3.h **** /** \brief  Structure type to access the System Control Block (SCB).
 238:./Core/core_cm3.h ****  */
 239:./Core/core_cm3.h **** typedef struct
 240:./Core/core_cm3.h **** {
 241:./Core/core_cm3.h ****   __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPU ID Base Register            
 242:./Core/core_cm3.h ****   __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control State Register
 243:./Core/core_cm3.h ****   __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register    
 244:./Core/core_cm3.h ****   __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt / Reset Co
 245:./Core/core_cm3.h ****   __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register         
 246:./Core/core_cm3.h ****   __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register  
 247:./Core/core_cm3.h ****   __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registe
 248:./Core/core_cm3.h ****   __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State
 249:./Core/core_cm3.h ****   __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Regist
 250:./Core/core_cm3.h ****   __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  Hard Fault Status Register      
 251:./Core/core_cm3.h ****   __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register     
 252:./Core/core_cm3.h ****   __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  Mem Manage Address Register     
 253:./Core/core_cm3.h ****   __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  Bus Fault Address Register      
 254:./Core/core_cm3.h ****   __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register 
 255:./Core/core_cm3.h ****   __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register      
 256:./Core/core_cm3.h ****   __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register          
 257:./Core/core_cm3.h ****   __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register      
 258:./Core/core_cm3.h ****   __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register   
 259:./Core/core_cm3.h ****   __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  ISA Feature Register            
 260:./Core/core_cm3.h **** } SCB_Type;
 261:./Core/core_cm3.h **** 
 262:./Core/core_cm3.h **** /* SCB CPUID Register Definitions */
 263:./Core/core_cm3.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB 
 264:./Core/core_cm3.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 265:./Core/core_cm3.h **** 
 266:./Core/core_cm3.h **** #define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB 
 267:./Core/core_cm3.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 268:./Core/core_cm3.h **** 
 269:./Core/core_cm3.h **** #define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB 
 270:./Core/core_cm3.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 271:./Core/core_cm3.h **** 
 272:./Core/core_cm3.h **** #define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB 
 273:./Core/core_cm3.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB 
 274:./Core/core_cm3.h **** 
 275:./Core/core_cm3.h **** /* SCB Interrupt Control State Register Definitions */
 276:./Core/core_cm3.h **** #define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB 
 277:./Core/core_cm3.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 278:./Core/core_cm3.h **** 
 279:./Core/core_cm3.h **** #define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB 
 280:./Core/core_cm3.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 281:./Core/core_cm3.h **** 
 282:./Core/core_cm3.h **** #define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB 
 283:./Core/core_cm3.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 284:./Core/core_cm3.h **** 
 285:./Core/core_cm3.h **** #define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB 
 286:./Core/core_cm3.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 287:./Core/core_cm3.h **** 
 288:./Core/core_cm3.h **** #define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB 
 289:./Core/core_cm3.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 290:./Core/core_cm3.h **** 
 291:./Core/core_cm3.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB 
 292:./Core/core_cm3.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 293:./Core/core_cm3.h **** 
 294:./Core/core_cm3.h **** #define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB 
 295:./Core/core_cm3.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 296:./Core/core_cm3.h **** 
 297:./Core/core_cm3.h **** #define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB 
 298:./Core/core_cm3.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 299:./Core/core_cm3.h **** 
 300:./Core/core_cm3.h **** #define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB 
 301:./Core/core_cm3.h **** #define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB 
 302:./Core/core_cm3.h **** 
 303:./Core/core_cm3.h **** #define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB 
 304:./Core/core_cm3.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB 
 305:./Core/core_cm3.h **** 
 306:./Core/core_cm3.h **** /* SCB Interrupt Control State Register Definitions */
 307:./Core/core_cm3.h **** #define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB 
 308:./Core/core_cm3.h **** #define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB 
 309:./Core/core_cm3.h **** 
 310:./Core/core_cm3.h **** #define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB 
 311:./Core/core_cm3.h **** #define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB 
 312:./Core/core_cm3.h **** 
 313:./Core/core_cm3.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 314:./Core/core_cm3.h **** #define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB 
 315:./Core/core_cm3.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 316:./Core/core_cm3.h **** 
 317:./Core/core_cm3.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB 
 318:./Core/core_cm3.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 319:./Core/core_cm3.h **** 
 320:./Core/core_cm3.h **** #define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB 
 321:./Core/core_cm3.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 322:./Core/core_cm3.h **** 
 323:./Core/core_cm3.h **** #define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB 
 324:./Core/core_cm3.h **** #define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB 
 325:./Core/core_cm3.h **** 
 326:./Core/core_cm3.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB 
 327:./Core/core_cm3.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 328:./Core/core_cm3.h **** 
 329:./Core/core_cm3.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB 
 330:./Core/core_cm3.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 331:./Core/core_cm3.h **** 
 332:./Core/core_cm3.h **** #define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB 
 333:./Core/core_cm3.h **** #define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB 
 334:./Core/core_cm3.h **** 
 335:./Core/core_cm3.h **** /* SCB System Control Register Definitions */
 336:./Core/core_cm3.h **** #define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB 
 337:./Core/core_cm3.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 338:./Core/core_cm3.h **** 
 339:./Core/core_cm3.h **** #define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB 
 340:./Core/core_cm3.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 341:./Core/core_cm3.h **** 
 342:./Core/core_cm3.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB 
 343:./Core/core_cm3.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 344:./Core/core_cm3.h **** 
 345:./Core/core_cm3.h **** /* SCB Configuration Control Register Definitions */
 346:./Core/core_cm3.h **** #define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB 
 347:./Core/core_cm3.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 348:./Core/core_cm3.h **** 
 349:./Core/core_cm3.h **** #define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB 
 350:./Core/core_cm3.h **** #define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB 
 351:./Core/core_cm3.h **** 
 352:./Core/core_cm3.h **** #define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB 
 353:./Core/core_cm3.h **** #define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB 
 354:./Core/core_cm3.h **** 
 355:./Core/core_cm3.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB 
 356:./Core/core_cm3.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 357:./Core/core_cm3.h **** 
 358:./Core/core_cm3.h **** #define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB 
 359:./Core/core_cm3.h **** #define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB 
 360:./Core/core_cm3.h **** 
 361:./Core/core_cm3.h **** #define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB 
 362:./Core/core_cm3.h **** #define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB 
 363:./Core/core_cm3.h **** 
 364:./Core/core_cm3.h **** /* SCB System Handler Control and State Register Definitions */
 365:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB 
 366:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB 
 367:./Core/core_cm3.h **** 
 368:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB 
 369:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB 
 370:./Core/core_cm3.h **** 
 371:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB 
 372:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB 
 373:./Core/core_cm3.h **** 
 374:./Core/core_cm3.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB 
 375:./Core/core_cm3.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 376:./Core/core_cm3.h **** 
 377:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB 
 378:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB 
 379:./Core/core_cm3.h **** 
 380:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB 
 381:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB 
 382:./Core/core_cm3.h **** 
 383:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB 
 384:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB 
 385:./Core/core_cm3.h **** 
 386:./Core/core_cm3.h **** #define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB 
 387:./Core/core_cm3.h **** #define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB 
 388:./Core/core_cm3.h **** 
 389:./Core/core_cm3.h **** #define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB 
 390:./Core/core_cm3.h **** #define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB 
 391:./Core/core_cm3.h **** 
 392:./Core/core_cm3.h **** #define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB 
 393:./Core/core_cm3.h **** #define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB 
 394:./Core/core_cm3.h **** 
 395:./Core/core_cm3.h **** #define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB 
 396:./Core/core_cm3.h **** #define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB 
 397:./Core/core_cm3.h **** 
 398:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB 
 399:./Core/core_cm3.h **** #define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB 
 400:./Core/core_cm3.h **** 
 401:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB 
 402:./Core/core_cm3.h **** #define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB 
 403:./Core/core_cm3.h **** 
 404:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB 
 405:./Core/core_cm3.h **** #define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB 
 406:./Core/core_cm3.h **** 
 407:./Core/core_cm3.h **** /* SCB Configurable Fault Status Registers Definitions */
 408:./Core/core_cm3.h **** #define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB 
 409:./Core/core_cm3.h **** #define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB 
 410:./Core/core_cm3.h **** 
 411:./Core/core_cm3.h **** #define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB 
 412:./Core/core_cm3.h **** #define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB 
 413:./Core/core_cm3.h **** 
 414:./Core/core_cm3.h **** #define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB 
 415:./Core/core_cm3.h **** #define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB 
 416:./Core/core_cm3.h **** 
 417:./Core/core_cm3.h **** /* SCB Hard Fault Status Registers Definitions */
 418:./Core/core_cm3.h **** #define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB 
 419:./Core/core_cm3.h **** #define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB 
 420:./Core/core_cm3.h **** 
 421:./Core/core_cm3.h **** #define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB 
 422:./Core/core_cm3.h **** #define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB 
 423:./Core/core_cm3.h **** 
 424:./Core/core_cm3.h **** #define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB 
 425:./Core/core_cm3.h **** #define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB 
 426:./Core/core_cm3.h **** 
 427:./Core/core_cm3.h **** /* SCB Debug Fault Status Register Definitions */
 428:./Core/core_cm3.h **** #define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB 
 429:./Core/core_cm3.h **** #define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB 
 430:./Core/core_cm3.h **** 
 431:./Core/core_cm3.h **** #define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB 
 432:./Core/core_cm3.h **** #define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB 
 433:./Core/core_cm3.h **** 
 434:./Core/core_cm3.h **** #define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB 
 435:./Core/core_cm3.h **** #define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB 
 436:./Core/core_cm3.h **** 
 437:./Core/core_cm3.h **** #define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB 
 438:./Core/core_cm3.h **** #define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB 
 439:./Core/core_cm3.h **** 
 440:./Core/core_cm3.h **** #define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB 
 441:./Core/core_cm3.h **** #define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB 
 442:./Core/core_cm3.h **** 
 443:./Core/core_cm3.h **** /*@} end of group CMSIS_SCB */
 444:./Core/core_cm3.h **** 
 445:./Core/core_cm3.h **** 
 446:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 447:./Core/core_cm3.h ****     \defgroup CMSIS_SysTick CMSIS SysTick
 448:./Core/core_cm3.h ****   Type definitions for the Cortex-M System Timer Registers
 449:./Core/core_cm3.h ****   @{
 450:./Core/core_cm3.h ****  */
 451:./Core/core_cm3.h **** 
 452:./Core/core_cm3.h **** /** \brief  Structure type to access the System Timer (SysTick).
 453:./Core/core_cm3.h ****  */
 454:./Core/core_cm3.h **** typedef struct
 455:./Core/core_cm3.h **** {
 456:./Core/core_cm3.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 457:./Core/core_cm3.h ****   __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register   
 458:./Core/core_cm3.h ****   __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register  
 459:./Core/core_cm3.h ****   __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register    
 460:./Core/core_cm3.h **** } SysTick_Type;
 461:./Core/core_cm3.h **** 
 462:./Core/core_cm3.h **** /* SysTick Control / Status Register Definitions */
 463:./Core/core_cm3.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysT
 464:./Core/core_cm3.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 465:./Core/core_cm3.h **** 
 466:./Core/core_cm3.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysT
 467:./Core/core_cm3.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 468:./Core/core_cm3.h **** 
 469:./Core/core_cm3.h **** #define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysT
 470:./Core/core_cm3.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 471:./Core/core_cm3.h **** 
 472:./Core/core_cm3.h **** #define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysT
 473:./Core/core_cm3.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysT
 474:./Core/core_cm3.h **** 
 475:./Core/core_cm3.h **** /* SysTick Reload Register Definitions */
 476:./Core/core_cm3.h **** #define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysT
 477:./Core/core_cm3.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysT
 478:./Core/core_cm3.h **** 
 479:./Core/core_cm3.h **** /* SysTick Current Register Definitions */
 480:./Core/core_cm3.h **** #define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysT
 481:./Core/core_cm3.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 482:./Core/core_cm3.h **** 
 483:./Core/core_cm3.h **** /* SysTick Calibration Register Definitions */
 484:./Core/core_cm3.h **** #define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysT
 485:./Core/core_cm3.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 486:./Core/core_cm3.h **** 
 487:./Core/core_cm3.h **** #define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysT
 488:./Core/core_cm3.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 489:./Core/core_cm3.h **** 
 490:./Core/core_cm3.h **** #define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysT
 491:./Core/core_cm3.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysT
 492:./Core/core_cm3.h **** 
 493:./Core/core_cm3.h **** /*@} end of group CMSIS_SysTick */
 494:./Core/core_cm3.h **** 
 495:./Core/core_cm3.h **** 
 496:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 497:./Core/core_cm3.h ****     \defgroup CMSIS_ITM CMSIS ITM
 498:./Core/core_cm3.h ****   Type definitions for the Cortex-M Instrumentation Trace Macrocell (ITM)
 499:./Core/core_cm3.h ****   @{
 500:./Core/core_cm3.h ****  */
 501:./Core/core_cm3.h **** 
 502:./Core/core_cm3.h **** /** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 503:./Core/core_cm3.h ****  */
 504:./Core/core_cm3.h **** typedef struct
 505:./Core/core_cm3.h **** {
 506:./Core/core_cm3.h ****   __O  union
 507:./Core/core_cm3.h ****   {
 508:./Core/core_cm3.h ****     __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit         
 509:./Core/core_cm3.h ****     __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit        
 510:./Core/core_cm3.h ****     __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit        
 511:./Core/core_cm3.h ****   }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers     
 512:./Core/core_cm3.h ****        uint32_t RESERVED0[864];
 513:./Core/core_cm3.h ****   __IO uint32_t TER;                     /*!< Offset:       (R/W)  ITM Trace Enable Register       
 514:./Core/core_cm3.h ****        uint32_t RESERVED1[15];
 515:./Core/core_cm3.h ****   __IO uint32_t TPR;                     /*!< Offset:       (R/W)  ITM Trace Privilege Register    
 516:./Core/core_cm3.h ****        uint32_t RESERVED2[15];
 517:./Core/core_cm3.h ****   __IO uint32_t TCR;                     /*!< Offset:       (R/W)  ITM Trace Control Register      
 518:./Core/core_cm3.h ****        uint32_t RESERVED3[29];
 519:./Core/core_cm3.h ****   __IO uint32_t IWR;                     /*!< Offset:       (R/W)  ITM Integration Write Register  
 520:./Core/core_cm3.h ****   __IO uint32_t IRR;                     /*!< Offset:       (R/W)  ITM Integration Read Register   
 521:./Core/core_cm3.h ****   __IO uint32_t IMCR;                    /*!< Offset:       (R/W)  ITM Integration Mode Control Reg
 522:./Core/core_cm3.h ****        uint32_t RESERVED4[43];
 523:./Core/core_cm3.h ****   __IO uint32_t LAR;                     /*!< Offset:       (R/W)  ITM Lock Access Register        
 524:./Core/core_cm3.h ****   __IO uint32_t LSR;                     /*!< Offset:       (R/W)  ITM Lock Status Register        
 525:./Core/core_cm3.h ****        uint32_t RESERVED5[6];
 526:./Core/core_cm3.h ****   __I  uint32_t PID4;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 527:./Core/core_cm3.h ****   __I  uint32_t PID5;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 528:./Core/core_cm3.h ****   __I  uint32_t PID6;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 529:./Core/core_cm3.h ****   __I  uint32_t PID7;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 530:./Core/core_cm3.h ****   __I  uint32_t PID0;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 531:./Core/core_cm3.h ****   __I  uint32_t PID1;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 532:./Core/core_cm3.h ****   __I  uint32_t PID2;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 533:./Core/core_cm3.h ****   __I  uint32_t PID3;                    /*!< Offset:       (R/ )  ITM Peripheral Identification Re
 534:./Core/core_cm3.h ****   __I  uint32_t CID0;                    /*!< Offset:       (R/ )  ITM Component  Identification Re
 535:./Core/core_cm3.h ****   __I  uint32_t CID1;                    /*!< Offset:       (R/ )  ITM Component  Identification Re
 536:./Core/core_cm3.h ****   __I  uint32_t CID2;                    /*!< Offset:       (R/ )  ITM Component  Identification Re
 537:./Core/core_cm3.h ****   __I  uint32_t CID3;                    /*!< Offset:       (R/ )  ITM Component  Identification Re
 538:./Core/core_cm3.h **** } ITM_Type;
 539:./Core/core_cm3.h **** 
 540:./Core/core_cm3.h **** /* ITM Trace Privilege Register Definitions */
 541:./Core/core_cm3.h **** #define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM 
 542:./Core/core_cm3.h **** #define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM 
 543:./Core/core_cm3.h **** 
 544:./Core/core_cm3.h **** /* ITM Trace Control Register Definitions */
 545:./Core/core_cm3.h **** #define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM 
 546:./Core/core_cm3.h **** #define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM 
 547:./Core/core_cm3.h **** 
 548:./Core/core_cm3.h **** #define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM 
 549:./Core/core_cm3.h **** #define ITM_TCR_ATBID_Msk                  (0x7FUL << ITM_TCR_ATBID_Pos)                  /*!< ITM 
 550:./Core/core_cm3.h **** 
 551:./Core/core_cm3.h **** #define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM 
 552:./Core/core_cm3.h **** #define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM 
 553:./Core/core_cm3.h **** 
 554:./Core/core_cm3.h **** #define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM 
 555:./Core/core_cm3.h **** #define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM 
 556:./Core/core_cm3.h **** 
 557:./Core/core_cm3.h **** #define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM 
 558:./Core/core_cm3.h **** #define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM 
 559:./Core/core_cm3.h **** 
 560:./Core/core_cm3.h **** #define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM 
 561:./Core/core_cm3.h **** #define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM 
 562:./Core/core_cm3.h **** 
 563:./Core/core_cm3.h **** #define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM 
 564:./Core/core_cm3.h **** #define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM 
 565:./Core/core_cm3.h **** 
 566:./Core/core_cm3.h **** #define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM 
 567:./Core/core_cm3.h **** #define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM 
 568:./Core/core_cm3.h **** 
 569:./Core/core_cm3.h **** /* ITM Integration Write Register Definitions */
 570:./Core/core_cm3.h **** #define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM 
 571:./Core/core_cm3.h **** #define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM 
 572:./Core/core_cm3.h **** 
 573:./Core/core_cm3.h **** /* ITM Integration Read Register Definitions */
 574:./Core/core_cm3.h **** #define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM 
 575:./Core/core_cm3.h **** #define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM 
 576:./Core/core_cm3.h **** 
 577:./Core/core_cm3.h **** /* ITM Integration Mode Control Register Definitions */
 578:./Core/core_cm3.h **** #define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM 
 579:./Core/core_cm3.h **** #define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM 
 580:./Core/core_cm3.h **** 
 581:./Core/core_cm3.h **** /* ITM Lock Status Register Definitions */
 582:./Core/core_cm3.h **** #define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM 
 583:./Core/core_cm3.h **** #define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM 
 584:./Core/core_cm3.h **** 
 585:./Core/core_cm3.h **** #define ITM_LSR_Access_Pos                  1                                             /*!< ITM 
 586:./Core/core_cm3.h **** #define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM 
 587:./Core/core_cm3.h **** 
 588:./Core/core_cm3.h **** #define ITM_LSR_Present_Pos                 0                                             /*!< ITM 
 589:./Core/core_cm3.h **** #define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM 
 590:./Core/core_cm3.h **** 
 591:./Core/core_cm3.h **** /*@}*/ /* end of group CMSIS_ITM */
 592:./Core/core_cm3.h **** 
 593:./Core/core_cm3.h **** 
 594:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 595:./Core/core_cm3.h ****     \defgroup CMSIS_InterruptType CMSIS Interrupt Type
 596:./Core/core_cm3.h ****   Type definitions for the Cortex-M Interrupt Type Register
 597:./Core/core_cm3.h ****   @{
 598:./Core/core_cm3.h ****  */
 599:./Core/core_cm3.h **** 
 600:./Core/core_cm3.h **** /** \brief  Structure type to access the Interrupt Type Register.
 601:./Core/core_cm3.h ****  */
 602:./Core/core_cm3.h **** typedef struct
 603:./Core/core_cm3.h **** {
 604:./Core/core_cm3.h ****        uint32_t RESERVED0;
 605:./Core/core_cm3.h ****   __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Control Type Register 
 606:./Core/core_cm3.h **** #if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
 607:./Core/core_cm3.h ****   __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      
 608:./Core/core_cm3.h **** #else
 609:./Core/core_cm3.h ****        uint32_t RESERVED1;
 610:./Core/core_cm3.h **** #endif
 611:./Core/core_cm3.h **** } InterruptType_Type;
 612:./Core/core_cm3.h **** 
 613:./Core/core_cm3.h **** /* Interrupt Controller Type Register Definitions */
 614:./Core/core_cm3.h **** #define IntType_ICTR_INTLINESNUM_Pos  0                                                   /*!< Inte
 615:./Core/core_cm3.h **** #define IntType_ICTR_INTLINESNUM_Msk (0x1FUL << IntType_ICTR_INTLINESNUM_Pos)             /*!< Inte
 616:./Core/core_cm3.h **** 
 617:./Core/core_cm3.h **** /* Auxiliary Control Register Definitions */
 618:./Core/core_cm3.h **** #define IntType_ACTLR_DISFOLD_Pos     2                                                   /*!< Inte
 619:./Core/core_cm3.h **** #define IntType_ACTLR_DISFOLD_Msk    (1UL << IntType_ACTLR_DISFOLD_Pos)                   /*!< Inte
 620:./Core/core_cm3.h **** 
 621:./Core/core_cm3.h **** #define IntType_ACTLR_DISDEFWBUF_Pos  1                                                   /*!< Inte
 622:./Core/core_cm3.h **** #define IntType_ACTLR_DISDEFWBUF_Msk (1UL << IntType_ACTLR_DISDEFWBUF_Pos)                /*!< Inte
 623:./Core/core_cm3.h **** 
 624:./Core/core_cm3.h **** #define IntType_ACTLR_DISMCYCINT_Pos  0                                                   /*!< Inte
 625:./Core/core_cm3.h **** #define IntType_ACTLR_DISMCYCINT_Msk (1UL << IntType_ACTLR_DISMCYCINT_Pos)                /*!< Inte
 626:./Core/core_cm3.h **** 
 627:./Core/core_cm3.h **** /*@}*/ /* end of group CMSIS_InterruptType */
 628:./Core/core_cm3.h **** 
 629:./Core/core_cm3.h **** 
 630:./Core/core_cm3.h **** #if (__MPU_PRESENT == 1)
 631:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 632:./Core/core_cm3.h ****     \defgroup CMSIS_MPU CMSIS MPU
 633:./Core/core_cm3.h ****   Type definitions for the Cortex-M Memory Protection Unit (MPU)
 634:./Core/core_cm3.h ****   @{
 635:./Core/core_cm3.h ****  */
 636:./Core/core_cm3.h **** 
 637:./Core/core_cm3.h **** /** \brief  Structure type to access the Memory Protection Unit (MPU).
 638:./Core/core_cm3.h ****  */
 639:./Core/core_cm3.h **** typedef struct
 640:./Core/core_cm3.h **** {
 641:./Core/core_cm3.h ****   __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register               
 642:./Core/core_cm3.h ****   __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register            
 643:./Core/core_cm3.h ****   __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register      
 644:./Core/core_cm3.h ****   __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register
 645:./Core/core_cm3.h ****   __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Re
 646:./Core/core_cm3.h ****   __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address 
 647:./Core/core_cm3.h ****   __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and
 648:./Core/core_cm3.h ****   __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address 
 649:./Core/core_cm3.h ****   __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and
 650:./Core/core_cm3.h ****   __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address 
 651:./Core/core_cm3.h ****   __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and
 652:./Core/core_cm3.h **** } MPU_Type;
 653:./Core/core_cm3.h **** 
 654:./Core/core_cm3.h **** /* MPU Type Register */
 655:./Core/core_cm3.h **** #define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU 
 656:./Core/core_cm3.h **** #define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU 
 657:./Core/core_cm3.h **** 
 658:./Core/core_cm3.h **** #define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU 
 659:./Core/core_cm3.h **** #define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU 
 660:./Core/core_cm3.h **** 
 661:./Core/core_cm3.h **** #define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU 
 662:./Core/core_cm3.h **** #define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU 
 663:./Core/core_cm3.h **** 
 664:./Core/core_cm3.h **** /* MPU Control Register */
 665:./Core/core_cm3.h **** #define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU 
 666:./Core/core_cm3.h **** #define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU 
 667:./Core/core_cm3.h **** 
 668:./Core/core_cm3.h **** #define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU 
 669:./Core/core_cm3.h **** #define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU 
 670:./Core/core_cm3.h **** 
 671:./Core/core_cm3.h **** #define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU 
 672:./Core/core_cm3.h **** #define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU 
 673:./Core/core_cm3.h **** 
 674:./Core/core_cm3.h **** /* MPU Region Number Register */
 675:./Core/core_cm3.h **** #define MPU_RNR_REGION_Pos                  0                                             /*!< MPU 
 676:./Core/core_cm3.h **** #define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU 
 677:./Core/core_cm3.h **** 
 678:./Core/core_cm3.h **** /* MPU Region Base Address Register */
 679:./Core/core_cm3.h **** #define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU 
 680:./Core/core_cm3.h **** #define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU 
 681:./Core/core_cm3.h **** 
 682:./Core/core_cm3.h **** #define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU 
 683:./Core/core_cm3.h **** #define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU 
 684:./Core/core_cm3.h **** 
 685:./Core/core_cm3.h **** #define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU 
 686:./Core/core_cm3.h **** #define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU 
 687:./Core/core_cm3.h **** 
 688:./Core/core_cm3.h **** /* MPU Region Attribute and Size Register */
 689:./Core/core_cm3.h **** #define MPU_RASR_XN_Pos                    28                                             /*!< MPU 
 690:./Core/core_cm3.h **** #define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU 
 691:./Core/core_cm3.h **** 
 692:./Core/core_cm3.h **** #define MPU_RASR_AP_Pos                    24                                             /*!< MPU 
 693:./Core/core_cm3.h **** #define MPU_RASR_AP_Msk                    (7UL << MPU_RASR_AP_Pos)                       /*!< MPU 
 694:./Core/core_cm3.h **** 
 695:./Core/core_cm3.h **** #define MPU_RASR_TEX_Pos                   19                                             /*!< MPU 
 696:./Core/core_cm3.h **** #define MPU_RASR_TEX_Msk                   (7UL << MPU_RASR_TEX_Pos)                      /*!< MPU 
 697:./Core/core_cm3.h **** 
 698:./Core/core_cm3.h **** #define MPU_RASR_S_Pos                     18                                             /*!< MPU 
 699:./Core/core_cm3.h **** #define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU 
 700:./Core/core_cm3.h **** 
 701:./Core/core_cm3.h **** #define MPU_RASR_C_Pos                     17                                             /*!< MPU 
 702:./Core/core_cm3.h **** #define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU 
 703:./Core/core_cm3.h **** 
 704:./Core/core_cm3.h **** #define MPU_RASR_B_Pos                     16                                             /*!< MPU 
 705:./Core/core_cm3.h **** #define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU 
 706:./Core/core_cm3.h **** 
 707:./Core/core_cm3.h **** #define MPU_RASR_SRD_Pos                    8                                             /*!< MPU 
 708:./Core/core_cm3.h **** #define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU 
 709:./Core/core_cm3.h **** 
 710:./Core/core_cm3.h **** #define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU 
 711:./Core/core_cm3.h **** #define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU 
 712:./Core/core_cm3.h **** 
 713:./Core/core_cm3.h **** #define MPU_RASR_ENA_Pos                     0                                            /*!< MPU 
 714:./Core/core_cm3.h **** #define MPU_RASR_ENA_Msk                    (0x1UL << MPU_RASR_ENA_Pos)                   /*!< MPU 
 715:./Core/core_cm3.h **** 
 716:./Core/core_cm3.h **** /*@} end of group CMSIS_MPU */
 717:./Core/core_cm3.h **** #endif
 718:./Core/core_cm3.h **** 
 719:./Core/core_cm3.h **** 
 720:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 721:./Core/core_cm3.h ****     \defgroup CMSIS_CoreDebug CMSIS Core Debug
 722:./Core/core_cm3.h ****   Type definitions for the Cortex-M Core Debug Registers
 723:./Core/core_cm3.h ****   @{
 724:./Core/core_cm3.h ****  */
 725:./Core/core_cm3.h **** 
 726:./Core/core_cm3.h **** /** \brief  Structure type to access the Core Debug Register (CoreDebug).
 727:./Core/core_cm3.h ****  */
 728:./Core/core_cm3.h **** typedef struct
 729:./Core/core_cm3.h **** {
 730:./Core/core_cm3.h ****   __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status
 731:./Core/core_cm3.h ****   __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Reg
 732:./Core/core_cm3.h ****   __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Registe
 733:./Core/core_cm3.h ****   __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Cont
 734:./Core/core_cm3.h **** } CoreDebug_Type;
 735:./Core/core_cm3.h **** 
 736:./Core/core_cm3.h **** /* Debug Halting Control and Status Register */
 737:./Core/core_cm3.h **** #define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< Core
 738:./Core/core_cm3.h **** #define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< Core
 739:./Core/core_cm3.h **** 
 740:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< Core
 741:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< Core
 742:./Core/core_cm3.h **** 
 743:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< Core
 744:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< Core
 745:./Core/core_cm3.h **** 
 746:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< Core
 747:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< Core
 748:./Core/core_cm3.h **** 
 749:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< Core
 750:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< Core
 751:./Core/core_cm3.h **** 
 752:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< Core
 753:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< Core
 754:./Core/core_cm3.h **** 
 755:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< Core
 756:./Core/core_cm3.h **** #define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< Core
 757:./Core/core_cm3.h **** 
 758:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< Core
 759:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< Core
 760:./Core/core_cm3.h **** 
 761:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< Core
 762:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< Core
 763:./Core/core_cm3.h **** 
 764:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< Core
 765:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< Core
 766:./Core/core_cm3.h **** 
 767:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< Core
 768:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< Core
 769:./Core/core_cm3.h **** 
 770:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< Core
 771:./Core/core_cm3.h **** #define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< Core
 772:./Core/core_cm3.h **** 
 773:./Core/core_cm3.h **** /* Debug Core Register Selector Register */
 774:./Core/core_cm3.h **** #define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< Core
 775:./Core/core_cm3.h **** #define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< Core
 776:./Core/core_cm3.h **** 
 777:./Core/core_cm3.h **** #define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< Core
 778:./Core/core_cm3.h **** #define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< Core
 779:./Core/core_cm3.h **** 
 780:./Core/core_cm3.h **** /* Debug Exception and Monitor Control Register */
 781:./Core/core_cm3.h **** #define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< Core
 782:./Core/core_cm3.h **** #define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< Core
 783:./Core/core_cm3.h **** 
 784:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< Core
 785:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< Core
 786:./Core/core_cm3.h **** 
 787:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< Core
 788:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< Core
 789:./Core/core_cm3.h **** 
 790:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< Core
 791:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< Core
 792:./Core/core_cm3.h **** 
 793:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< Core
 794:./Core/core_cm3.h **** #define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< Core
 795:./Core/core_cm3.h **** 
 796:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< Core
 797:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< Core
 798:./Core/core_cm3.h **** 
 799:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< Core
 800:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< Core
 801:./Core/core_cm3.h **** 
 802:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< Core
 803:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< Core
 804:./Core/core_cm3.h **** 
 805:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< Core
 806:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< Core
 807:./Core/core_cm3.h **** 
 808:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< Core
 809:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< Core
 810:./Core/core_cm3.h **** 
 811:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< Core
 812:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< Core
 813:./Core/core_cm3.h **** 
 814:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< Core
 815:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< Core
 816:./Core/core_cm3.h **** 
 817:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< Core
 818:./Core/core_cm3.h **** #define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< Core
 819:./Core/core_cm3.h **** 
 820:./Core/core_cm3.h **** /*@} end of group CMSIS_CoreDebug */
 821:./Core/core_cm3.h **** 
 822:./Core/core_cm3.h **** 
 823:./Core/core_cm3.h **** /** \ingroup  CMSIS_core_register
 824:./Core/core_cm3.h ****   @{
 825:./Core/core_cm3.h ****  */
 826:./Core/core_cm3.h **** 
 827:./Core/core_cm3.h **** /* Memory mapping of Cortex-M3 Hardware */
 828:./Core/core_cm3.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 829:./Core/core_cm3.h **** #define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address        
 830:./Core/core_cm3.h **** #define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address 
 831:./Core/core_cm3.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address    
 832:./Core/core_cm3.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address       
 833:./Core/core_cm3.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 834:./Core/core_cm3.h **** 
 835:./Core/core_cm3.h **** #define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register 
 836:./Core/core_cm3.h **** #define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct
 837:./Core/core_cm3.h **** #define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration st
 838:./Core/core_cm3.h **** #define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struc
 839:./Core/core_cm3.h **** #define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct
 840:./Core/core_cm3.h **** #define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration
 841:./Core/core_cm3.h **** 
 842:./Core/core_cm3.h **** #if (__MPU_PRESENT == 1)
 843:./Core/core_cm3.h ****   #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit  
 844:./Core/core_cm3.h ****   #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit  
 845:./Core/core_cm3.h **** #endif
 846:./Core/core_cm3.h **** 
 847:./Core/core_cm3.h **** /*@} */
 848:./Core/core_cm3.h **** 
 849:./Core/core_cm3.h **** 
 850:./Core/core_cm3.h **** 
 851:./Core/core_cm3.h **** /*******************************************************************************
 852:./Core/core_cm3.h ****  *                Hardware Abstraction Layer
 853:./Core/core_cm3.h ****  ******************************************************************************/
 854:./Core/core_cm3.h **** /** \addtogroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
 855:./Core/core_cm3.h ****   Core Function Interface contains:
 856:./Core/core_cm3.h ****   - Core NVIC Functions
 857:./Core/core_cm3.h ****   - Core SysTick Functions
 858:./Core/core_cm3.h ****   - Core Debug Functions
 859:./Core/core_cm3.h ****   - Core Register Access Functions
 860:./Core/core_cm3.h **** */
 861:./Core/core_cm3.h **** 
 862:./Core/core_cm3.h **** 
 863:./Core/core_cm3.h **** 
 864:./Core/core_cm3.h **** /* ##########################   NVIC functions  #################################### */
 865:./Core/core_cm3.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 866:./Core/core_cm3.h ****     \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
 867:./Core/core_cm3.h ****   @{
 868:./Core/core_cm3.h ****  */
 869:./Core/core_cm3.h **** /** @addtogroup CMSIS_Core_NVICFunctions
 870:./Core/core_cm3.h ****  * @{
 871:./Core/core_cm3.h ****  */
 872:./Core/core_cm3.h **** /** \brief  Set Priority Grouping
 873:./Core/core_cm3.h **** 
 874:./Core/core_cm3.h ****   This function sets the priority grouping field using the required unlock sequence.
 875:./Core/core_cm3.h ****   The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
 876:./Core/core_cm3.h ****   Only values from 0..7 are used.
 877:./Core/core_cm3.h ****   In case of a conflict between priority grouping and available
 878:./Core/core_cm3.h ****   priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
 879:./Core/core_cm3.h **** 
 880:./Core/core_cm3.h ****     \param [in]      PriorityGroup  Priority grouping field
 881:./Core/core_cm3.h ****  */
 882:./Core/core_cm3.h **** static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
 883:./Core/core_cm3.h **** {
 884:./Core/core_cm3.h ****   uint32_t reg_value;
 885:./Core/core_cm3.h ****   uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 a
 886:./Core/core_cm3.h **** 
 887:./Core/core_cm3.h ****   reg_value  =  SCB->AIRCR;                                                   /* read old register 
 888:./Core/core_cm3.h ****   reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to chan
 889:./Core/core_cm3.h ****   reg_value  =  (reg_value                       |
 890:./Core/core_cm3.h ****                 (0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 891:./Core/core_cm3.h ****                 (PriorityGroupTmp << 8));                                     /* Insert write key a
 892:./Core/core_cm3.h ****   SCB->AIRCR =  reg_value;
 893:./Core/core_cm3.h **** }
 894:./Core/core_cm3.h **** 
 895:./Core/core_cm3.h **** 
 896:./Core/core_cm3.h **** /** \brief  Get Priority Grouping
 897:./Core/core_cm3.h **** 
 898:./Core/core_cm3.h ****   This function gets the priority grouping from NVIC Interrupt Controller.
 899:./Core/core_cm3.h ****   Priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
 900:./Core/core_cm3.h **** 
 901:./Core/core_cm3.h ****     \return                Priority grouping field
 902:./Core/core_cm3.h ****  */
 903:./Core/core_cm3.h **** static __INLINE uint32_t NVIC_GetPriorityGrouping(void)
 904:./Core/core_cm3.h **** {
 905:./Core/core_cm3.h ****   return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grou
 906:./Core/core_cm3.h **** }
 907:./Core/core_cm3.h **** 
 908:./Core/core_cm3.h **** 
 909:./Core/core_cm3.h **** /** \brief  Enable External Interrupt
 910:./Core/core_cm3.h **** 
 911:./Core/core_cm3.h ****     This function enables a device specific interupt in the NVIC interrupt controller.
 912:./Core/core_cm3.h ****     The interrupt number cannot be a negative value.
 913:./Core/core_cm3.h **** 
 914:./Core/core_cm3.h ****     \param [in]      IRQn  Number of the external interrupt to enable
 915:./Core/core_cm3.h ****  */
 916:./Core/core_cm3.h **** static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 917:./Core/core_cm3.h **** {
 918:./Core/core_cm3.h ****   NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 1201              		.loc 2 918 0
 1202 0014 154A     		ldr	r2, .L123+12
 1203              	.LBE13:
 1204              	.LBE12:
 1205              		.loc 1 525 0
 1206 0016 03F07F03 		and	r3, r3, #127
 1207 001a 2373     		strb	r3, [r4, #12]
 526:./src/Main.c  **** 
 527:./src/Main.c  ****     LPC_UART0->IER |= (1<<0) | (1<<1) | (1<<2);  //enable IRQ
 1208              		.loc 1 527 0
 1209 001c 6068     		ldr	r0, [r4, #4]
 528:./src/Main.c  ****     NVIC_EnableIRQ(UART0_IRQn);
 529:./src/Main.c  **** 
 530:./src/Main.c  **** 
 531:./src/Main.c  **** 	LPC_GPIO0->FIODIR |= (1<<0);
 1210              		.loc 1 531 0
 1211 001e 144B     		ldr	r3, .L123+16
 1212              	.LBB16:
 1213              	.LBB14:
 1214              		.loc 2 918 0
 1215 0020 2021     		movs	r1, #32
 1216              	.LBE14:
 1217              	.LBE16:
 527:./src/Main.c  ****     LPC_UART0->IER |= (1<<0) | (1<<1) | (1<<2);  //enable IRQ
 1218              		.loc 1 527 0
 1219 0022 40F00700 		orr	r0, r0, #7
 1220 0026 6060     		str	r0, [r4, #4]
 1221              	.LVL66:
 1222              	.LBB17:
 1223              	.LBB15:
 1224              		.loc 2 918 0
 1225 0028 1160     		str	r1, [r2]
 1226              	.LBE15:
 1227              	.LBE17:
 1228              		.loc 1 531 0
 1229 002a 1968     		ldr	r1, [r3]
 532:./src/Main.c  **** 	LPC_GPIO0->FIOCLR0 |= (1<<0);
 533:./src/Main.c  **** 
 534:./src/Main.c  **** 	LPC_GPIO0->FIODIR |= (1<<1);
 535:./src/Main.c  **** 	LPC_GPIO0->FIOCLR0 |= (1<<1);
 536:./src/Main.c  **** 
 537:./src/Main.c  **** 	LPC_GPIO1->FIODIR3 |= (0<<5);
 1230              		.loc 1 537 0
 1231 002c 114A     		ldr	r2, .L123+20
 531:./src/Main.c  **** 	LPC_GPIO0->FIODIR |= (1<<0);
 1232              		.loc 1 531 0
 1233 002e 41F00101 		orr	r1, r1, #1
 1234 0032 1960     		str	r1, [r3]
 532:./src/Main.c  **** 	LPC_GPIO0->FIOCLR0 |= (1<<0);
 1235              		.loc 1 532 0
 1236 0034 187F     		ldrb	r0, [r3, #28]	@ zero_extendqisi2
 538:./src/Main.c  **** 
 539:./src/Main.c  **** 	myStat = doNothing;
 1237              		.loc 1 539 0
 1238 0036 1049     		ldr	r1, .L123+24
 532:./src/Main.c  **** 	LPC_GPIO0->FIOCLR0 |= (1<<0);
 1239              		.loc 1 532 0
 1240 0038 40F00100 		orr	r0, r0, #1
 1241 003c 1877     		strb	r0, [r3, #28]
 534:./src/Main.c  **** 	LPC_GPIO0->FIODIR |= (1<<1);
 1242              		.loc 1 534 0
 1243 003e 1C68     		ldr	r4, [r3]
 1244              		.loc 1 539 0
 1245 0040 0020     		movs	r0, #0
 534:./src/Main.c  **** 	LPC_GPIO0->FIODIR |= (1<<1);
 1246              		.loc 1 534 0
 1247 0042 44F00204 		orr	r4, r4, #2
 1248 0046 1C60     		str	r4, [r3]
 535:./src/Main.c  **** 	LPC_GPIO0->FIOCLR0 |= (1<<1);
 1249              		.loc 1 535 0
 1250 0048 1C7F     		ldrb	r4, [r3, #28]	@ zero_extendqisi2
 1251 004a 44F00204 		orr	r4, r4, #2
 1252 004e 1C77     		strb	r4, [r3, #28]
 537:./src/Main.c  **** 	LPC_GPIO1->FIODIR3 |= (0<<5);
 1253              		.loc 1 537 0
 1254 0050 D378     		ldrb	r3, [r2, #3]	@ zero_extendqisi2
 1255 0052 DBB2     		uxtb	r3, r3
 1256 0054 D370     		strb	r3, [r2, #3]
 1257              		.loc 1 539 0
 1258 0056 0870     		strb	r0, [r1]
 1259              	.L122:
 540:./src/Main.c  **** 
 541:./src/Main.c  **** 
 542:./src/Main.c  **** 
 543:./src/Main.c  **** 	while (1)
 544:./src/Main.c  **** 	{
 545:./src/Main.c  **** 		Poll();
 1260              		.loc 1 545 0 discriminator 1
 1261 0058 FFF7FEFF 		bl	Poll
 1262              	.LVL67:
 1263 005c FCE7     		b	.L122
 1264              	.L124:
 1265 005e 00BF     		.align	2
 1266              	.L123:
 1267 0060 00C00040 		.word	1073790976
 1268 0064 00000000 		.word	_db_msg
 1269 0068 E4000000 		.word	.LC12
 1270 006c 00E100E0 		.word	-536813312
 1271 0070 00C00920 		.word	537509888
 1272 0074 20C00920 		.word	537509920
 1273 0078 00000000 		.word	myStat
 1274              		.cfi_endproc
 1275              	.LFE63:
 1277              		.comm	myStat,1,1
 1278              		.global	pbit
 1279              		.comm	byte,4,4
 1280              		.global	pCom
 1281              		.global	CommList
 1282              		.global	n
 1283              		.comm	Buf,255,4
 1284              		.comm	ch,1,1
 1285              		.section	.bss.nMatches.7721,"aw",%nobits
 1286              		.align	1
 1287              		.set	.LANCHOR6,. + 0
 1290              	nMatches.7721:
 1291 0000 0000     		.space	2
 1292              		.section	.bss.n,"aw",%nobits
 1293              		.align	1
 1294              		.set	.LANCHOR0,. + 0
 1297              	n:
 1298 0000 0000     		.space	2
 1299              		.section	.data.pCom,"aw",%progbits
 1300              		.align	2
 1301              		.set	.LANCHOR3,. + 0
 1304              	pCom:
 1305 0000 00000000 		.word	CommList
 1306              		.section	.data.CommList,"aw",%progbits
 1307              		.align	2
 1308              		.set	.LANCHOR4,. + 0
 1311              	CommList:
 1312 0000 00       		.byte	0
 1313 0001 00       		.byte	0
 1314 0002 30303030 		.ascii	"0000\000"
 1314      00
 1315 0007 00000000 		.space	20
 1315      00000000 
 1315      00000000 
 1315      00000000 
 1315      00000000 
 1316 001b 00       		.byte	0
 1317 001c 00       		.byte	0
 1318 001d 01       		.byte	1
 1319 001e 00       		.byte	0
 1320 001f 41444452 		.ascii	"ADDR\000"
 1320      00
 1321 0024 00000000 		.space	20
 1321      00000000 
 1321      00000000 
 1321      00000000 
 1321      00000000 
 1322 0038 04       		.byte	4
 1323 0039 02       		.byte	2
 1324 003a 02       		.byte	2
 1325 003b 00       		.byte	0
 1326 003c 4200     		.ascii	"B\000"
 1327 003e 00000000 		.space	23
 1327      00000000 
 1327      00000000 
 1327      00000000 
 1327      00000000 
 1328 0055 01       		.byte	1
 1329 0056 02       		.byte	2
 1330 0057 03       		.byte	3
 1331 0058 00       		.byte	0
 1332 0059 42415544 		.ascii	"BAUD\000"
 1332      00
 1333 005e 00000000 		.space	20
 1333      00000000 
 1333      00000000 
 1333      00000000 
 1333      00000000 
 1334 0072 04       		.byte	4
 1335 0073 02       		.byte	2
 1336 0074 04       		.byte	4
 1337 0075 00       		.byte	0
 1338 0076 424F00   		.ascii	"BO\000"
 1339 0079 00000000 		.space	22
 1339      00000000 
 1339      00000000 
 1339      00000000 
 1339      00000000 
 1340 008f 02       		.byte	2
 1341 0090 02       		.byte	2
 1342 0091 05       		.byte	5
 1343 0092 00       		.byte	0
 1344 0093 425300   		.ascii	"BS\000"
 1345 0096 00000000 		.space	22
 1345      00000000 
 1345      00000000 
 1345      00000000 
 1345      00000000 
 1346 00ac 02       		.byte	2
 1347 00ad 02       		.byte	2
 1348 00ae 06       		.byte	6
 1349 00af 00       		.byte	0
 1350 00b0 434F4E46 		.ascii	"CONF\000"
 1350      00
 1351 00b5 00000000 		.space	20
 1351      00000000 
 1351      00000000 
 1351      00000000 
 1351      00000000 
 1352 00c9 04       		.byte	4
 1353 00ca 02       		.byte	2
 1354 00cb 07       		.byte	7
 1355 00cc 00       		.byte	0
 1356 00cd 4400     		.ascii	"D\000"
 1357 00cf 00000000 		.space	23
 1357      00000000 
 1357      00000000 
 1357      00000000 
 1357      00000000 
 1358 00e6 01       		.byte	1
 1359 00e7 04       		.byte	4
 1360 00e8 08       		.byte	8
 1361 00e9 00       		.byte	0
 1362 00ea 464C4153 		.ascii	"FLASH\000"
 1362      4800
 1363 00f0 00000000 		.space	19
 1363      00000000 
 1363      00000000 
 1363      00000000 
 1363      000000
 1364 0103 05       		.byte	5
 1365 0104 02       		.byte	2
 1366 0105 09       		.byte	9
 1367 0106 00       		.byte	0
 1368 0107 494E5400 		.ascii	"INT\000"
 1369 010b 00000000 		.space	21
 1369      00000000 
 1369      00000000 
 1369      00000000 
 1369      00000000 
 1370 0120 03       		.byte	3
 1371 0121 02       		.byte	2
 1372 0122 0A       		.byte	10
 1373 0123 00       		.byte	0
 1374 0124 4F00     		.ascii	"O\000"
 1375 0126 00000000 		.space	23
 1375      00000000 
 1375      00000000 
 1375      00000000 
 1375      00000000 
 1376 013d 01       		.byte	1
 1377 013e 02       		.byte	2
 1378 013f 0B       		.byte	11
 1379 0140 00       		.byte	0
 1380 0141 505400   		.ascii	"PT\000"
 1381 0144 00000000 		.space	22
 1381      00000000 
 1381      00000000 
 1381      00000000 
 1381      00000000 
 1382 015a 02       		.byte	2
 1383 015b 02       		.byte	2
 1384 015c 0C       		.byte	12
 1385 015d 00       		.byte	0
 1386 015e 52535400 		.ascii	"RST\000"
 1387 0162 00000000 		.space	21
 1387      00000000 
 1387      00000000 
 1387      00000000 
 1387      00000000 
 1388 0177 03       		.byte	3
 1389 0178 01       		.byte	1
 1390 0179 0D       		.byte	13
 1391 017a 00       		.byte	0
 1392 017b 5253542F 		.ascii	"RST/C\000"
 1392      4300
 1393 0181 00000000 		.space	19
 1393      00000000 
 1393      00000000 
 1393      00000000 
 1393      000000
 1394 0194 05       		.byte	5
 1395 0195 01       		.byte	1
 1396 0196 0E       		.byte	14
 1397 0197 00       		.byte	0
 1398 0198 5300     		.ascii	"S\000"
 1399 019a 00000000 		.space	23
 1399      00000000 
 1399      00000000 
 1399      00000000 
 1399      00000000 
 1400 01b1 01       		.byte	1
 1401 01b2 02       		.byte	2
 1402 01b3 0F       		.byte	15
 1403 01b4 00       		.byte	0
 1404 01b5 57524954 		.ascii	"WRITE\000"
 1404      4500
 1405 01bb 00000000 		.space	19
 1405      00000000 
 1405      00000000 
 1405      00000000 
 1405      000000
 1406 01ce 05       		.byte	5
 1407 01cf 01       		.byte	1
 1408 01d0 10       		.byte	16
 1409 01d1 00       		.byte	0
 1410 01d2 52455345 		.ascii	"RESETTOFACTORY\000"
 1410      54544F46 
 1410      4143544F 
 1410      525900
 1411 01e1 00000000 		.space	10
 1411      00000000 
 1411      0000
 1412 01eb 0E       		.byte	14
 1413 01ec 01       		.byte	1
 1414 01ed 00000000 		.space	957
 1414      00000000 
 1414      00000000 
 1414      00000000 
 1414      00000000 
 1415 05aa 0000     		.section	.bss.value.7718,"aw",%nobits
 1416              		.align	2
 1417              		.set	.LANCHOR5,. + 0
 1420              	value.7718:
 1421 0000 00000000 		.space	50
 1421      00000000 
 1421      00000000 
 1421      00000000 
 1421      00000000 
 1422 0032 0000     		.section	.data.pbit,"aw",%progbits
 1423              		.align	2
 1424              		.set	.LANCHOR1,. + 0
 1427              	pbit:
 1428 0000 00000000 		.word	byte
 1429              		.section	.rodata.str1.4,"aMS",%progbits,1
 1430              		.align	2
 1431              	.LC0:
 1432 0000 20416464 		.ascii	" Address is invalid\015\012\000"
 1432      72657373 
 1432      20697320 
 1432      696E7661 
 1432      6C69640D 
 1433 0016 0000     		.space	2
 1434              	.LC1:
 1435 0018 61646472 		.ascii	"address is good\015\012\000"
 1435      65737320 
 1435      69732067 
 1435      6F6F640D 
 1435      0A00
 1436 002a 0000     		.space	2
 1437              	.LC2:
 1438 002c 73657373 		.ascii	"session_started\015\012\000"
 1438      696F6E5F 
 1438      73746172 
 1438      7465640D 
 1438      0A00
 1439 003e 0000     		.space	2
 1440              	.LC3:
 1441 0040 0D0A5365 		.ascii	"\015\012SecondSSS \015\012\000"
 1441      636F6E64 
 1441      53535320 
 1441      0D0A00
 1442 004f 00       		.space	1
 1443              	.LC4:
 1444 0050 0D0A7365 		.ascii	"\015\012session_finished\015\012\000"
 1444      7373696F 
 1444      6E5F6669 
 1444      6E697368 
 1444      65640D0A 
 1445 0065 000000   		.space	3
 1446              	.LC5:
 1447 0068 0D0A5353 		.ascii	"\015\012SSS - First \015\012\000"
 1447      53202D20 
 1447      46697273 
 1447      74200D0A 
 1447      00
 1448 0079 000000   		.space	3
 1449              	.LC6:
 1450 007c 0D0A5353 		.ascii	"\015\012SSS - Second \015\012\000"
 1450      53202D20 
 1450      5365636F 
 1450      6E64200D 
 1450      0A00
 1451 008e 0000     		.space	2
 1452              	.LC7:
 1453 0090 0D0A4572 		.ascii	"\015\012Error \015\012\000"
 1453      726F7220 
 1453      0D0A00
 1454 009b 00       		.space	1
 1455              	.LC8:
 1456 009c 0D0A4E6F 		.ascii	"\015\012Not found matches\015\012\000"
 1456      7420666F 
 1456      756E6420 
 1456      6D617463 
 1456      6865730D 
 1457 00b2 0000     		.space	2
 1458              	.LC9:
 1459 00b4 0D0A6574 		.ascii	"\015\012ething is good - \000"
 1459      68696E67 
 1459      20697320 
 1459      676F6F64 
 1459      202D2000 
 1460              	.LC10:
 1461 00c8 0D0A7661 		.ascii	"\015\012value - \000"
 1461      6C756520 
 1461      2D2000
 1462 00d3 00       		.space	1
 1463              	.LC11:
 1464 00d4 0D0A736D 		.ascii	"\015\012smthWrong\015\012\000"
 1464      74685772 
 1464      6F6E670D 
 1464      0A00
 1465 00e2 0000     		.space	2
 1466              	.LC12:
 1467 00e4 0D0A4865 		.ascii	"\015\012Hello I'am SHIM  ver. 0.1\015\012\000"
 1467      6C6C6F20 
 1467      4927616D 
 1467      20534849 
 1467      4D202076 
 1468 0102 0000     		.section	.bss.mainPointer,"aw",%nobits
 1469              		.align	1
 1470              		.set	.LANCHOR2,. + 0
 1473              	mainPointer:
 1474 0000 0000     		.space	2
 1475              		.section	.bss.nSymArg.7719,"aw",%nobits
 1476              		.align	1
 1477              		.set	.LANCHOR7,. + 0
 1480              	nSymArg.7719:
 1481 0000 0000     		.space	2
 1482              		.text
 1483              	.Letext0:
 1484              		.file 3 "./LPC17xx/LPC17xx.h"
 1485              		.file 4 "d:\\gnu\\4_8\\arm-none-eabi\\include\\machine\\_default_types.h"
 1486              		.file 5 "d:\\gnu\\4_8\\arm-none-eabi\\include\\stdint.h"
 1487              		.file 6 "./Drivers/include/debug_frmwrk.h"
DEFINED SYMBOLS
                            *ABS*:00000000 Main.c
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:19     .text._sbrk_r:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:24     .text._sbrk_r:00000000 _sbrk_r
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:37     .text.addrCheck:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:42     .text.addrCheck:00000000 addrCheck
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:160    .text.addrCheck:0000007c $d
                            *COM*:00000001 myStat
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:172    .text.receivingHandler:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:177    .text.receivingHandler:00000000 receivingHandler
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:476    .text.receivingHandler:000001ac $d
                            *COM*:00000001 ch
                            *COM*:000000ff Buf
                            *COM*:00000004 byte
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:496    .text.UART0_IRQHandler:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:501    .text.UART0_IRQHandler:00000000 UART0_IRQHandler
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:523    .text.UART0_IRQHandler:00000010 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:528    .text.Errors:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:533    .text.Errors:00000000 Errors
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:554    .text.Errors:00000010 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:561    .text.Parse:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:566    .text.Parse:00000000 Parse
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:710    .text.Parse:000000b8 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:716    .text.Poll:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:721    .text.Poll:00000000 Poll
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:746    .text.Poll:00000012 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1148   .text.Poll:00000218 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1170   .text.startup.main:00000000 $t
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1175   .text.startup.main:00000000 main
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1267   .text.startup.main:00000060 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1427   .data.pbit:00000000 pbit
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1304   .data.pCom:00000000 pCom
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1311   .data.CommList:00000000 CommList
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1297   .bss.n:00000000 n
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1286   .bss.nMatches.7721:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1290   .bss.nMatches.7721:00000000 nMatches.7721
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1293   .bss.n:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1300   .data.pCom:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1307   .data.CommList:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1416   .bss.value.7718:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1420   .bss.value.7718:00000000 value.7718
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1423   .data.pbit:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1430   .rodata.str1.4:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1469   .bss.mainPointer:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1473   .bss.mainPointer:00000000 mainPointer
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1476   .bss.nSymArg.7719:00000000 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:1480   .bss.nSymArg.7719:00000000 nSymArg.7719
                     .debug_frame:00000010 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:753    .text.Poll:00000019 $d
C:\Users\kosmos\AppData\Local\Temp\ccXhWxW7.s:753    .text.Poll:0000001a $t

UNDEFINED SYMBOLS
_db_msg
UARTGetChar
debug_frmwrk_init
